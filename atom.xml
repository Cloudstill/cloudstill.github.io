<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title> 云湍小站 </title>
  
  <subtitle> 来自云上的湍流 </subtitle>
  <link href="https://gitee.com/cloudstill/cloudstill.git/atom.xml" rel="self"/>
  
  <link href="https://gitee.com/cloudstill/cloudstill.git/"/>
  <updated>2023-08-04T15:39:27.878Z</updated>
  <id>https://gitee.com/cloudstill/cloudstill.git/</id>
  
  <author>
    <name>云湍/Cloudstill</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构_15：排序算法</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-15%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-15%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-08-04T15:39:27.000Z</published>
    <updated>2023-08-04T15:39:27.878Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构_14：图应用</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-14%EF%BC%9A%E5%9B%BE%E5%BA%94%E7%94%A8/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-14%EF%BC%9A%E5%9B%BE%E5%BA%94%E7%94%A8/</id>
    <published>2023-08-04T15:39:11.000Z</published>
    <updated>2023-08-04T15:39:11.923Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构_13：图</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-13%EF%BC%9A%E5%9B%BE/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-13%EF%BC%9A%E5%9B%BE/</id>
    <published>2023-08-04T15:38:54.000Z</published>
    <updated>2023-08-04T15:38:54.252Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构_12：散列表</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-12%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-12%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2023-08-04T15:38:42.000Z</published>
    <updated>2023-08-04T15:38:42.051Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构_11：树实战</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-11%EF%BC%9A%E6%A0%91%E5%AE%9E%E6%88%98/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-11%EF%BC%9A%E6%A0%91%E5%AE%9E%E6%88%98/</id>
    <published>2023-08-04T15:38:28.000Z</published>
    <updated>2023-08-04T15:38:28.808Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构_13：排序算法</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-13%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-13%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-08-04T15:37:28.000Z</published>
    <updated>2023-08-04T15:37:28.748Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构_10：其他树</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-10%EF%BC%9A%E5%85%B6%E4%BB%96%E6%A0%91/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-10%EF%BC%9A%E5%85%B6%E4%BB%96%E6%A0%91/</id>
    <published>2023-08-04T15:36:21.000Z</published>
    <updated>2023-08-04T15:36:21.295Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构_09：高级树</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-09%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%A0%91/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-09%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%A0%91/</id>
    <published>2023-08-04T15:35:43.000Z</published>
    <updated>2023-08-04T15:35:43.530Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构_08：二叉树</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-08%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-08%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-08-04T15:35:16.000Z</published>
    <updated>2023-08-04T15:35:16.625Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构_07：线性表实战</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-07%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9E%E6%88%98/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-07%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9E%E6%88%98/</id>
    <published>2023-08-04T15:34:40.000Z</published>
    <updated>2023-08-04T15:34:40.811Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构_06：队列</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-06%EF%BC%9A%E9%98%9F%E5%88%97/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-06%EF%BC%9A%E9%98%9F%E5%88%97/</id>
    <published>2023-08-04T15:34:09.000Z</published>
    <updated>2023-08-04T15:34:09.601Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数论杂记</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/04/02/%E6%95%B0%E8%AE%BA%E6%9D%82%E8%AE%B0/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/04/02/%E6%95%B0%E8%AE%BA%E6%9D%82%E8%AE%B0/</id>
    <published>2023-04-01T16:36:17.000Z</published>
    <updated>2023-04-05T03:35:16.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本打算将这篇博客取名数论基础，然而想想实在狂妄，本文仅仅记录了一些在做编程题时可能会用到的数学方法，离正统的数论还相差甚远，就数论杂记一名仍有蹭热度之嫌，不甚惶恐，留下这篇杂记。</p><h2 id="最大公约数-——-Greatest-Common-Divisor-GCD"><a href="#最大公约数-——-Greatest-Common-Divisor-GCD" class="headerlink" title="最大公约数 —— Greatest Common Divisor(GCD)"></a>最大公约数 —— Greatest Common Divisor(GCD)</h2><p>朴素的暴力法求最大公约数和辗转相除法的思想这里都不做赘述，我们仅仅介绍两种超快的求最大公约数算法：</p><ol><li><p>位运算法（a*b!&#x3D;0）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(b^=a^=b^=a%=b);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>if+while+位运算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b) <span class="keyword">while</span>((a%=b)&amp;&amp;(b%=a));</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="质数判断"><a href="#质数判断" class="headerlink" title="质数判断"></a>质数判断</h2><p>朴素的暴力法这里不再赘述，我们仅仅介绍一种超快的判断质数方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num==<span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(num==<span class="number">2</span>||num==<span class="number">3</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(num%<span class="number">6</span>!=<span class="number">1</span>&amp;&amp;num%<span class="number">6</span>!=<span class="number">5</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">int</span> tmp=<span class="built_in">sqrt</span>(num);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>;i&lt;=tmp;i+=<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">if</span>(num%i==<span class="number">0</span>||num%(i+<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="分解质数"><a href="#分解质数" class="headerlink" title="分解质数"></a>分解质数</h2><p>已知一个数可以分解成1和其本身相乘形式、或一种确定的若干个的质数相乘的形式，我们可以设计一种算法统计这些形式的长度（其中不包括1）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n=<span class="number">0</span>,m=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span>(i!=<span class="number">1</span>&amp;&amp;m&lt;=<span class="built_in">sqrt</span>(i))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(i%m==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      n++;</span><br><span class="line">      i/=m;</span><br><span class="line">    &#125;</span><br><span class="line">    m++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i!=<span class="number">1</span>)  n++;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以设计一个朴素的算法来输出这个序列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(m&gt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(m%n) n++;</span><br><span class="line">        cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        m/=n;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h2><p>在上文中我们提到了任何一个数都可以分解为质数相乘的形式，我们很容易联想到一个数的约数个数会和其质数数量存在某种联系，实际上也确实如此：</p><blockquote><p>一个数约数的个数等于其分解成的各个质数的幂次数加一之和的积。</p></blockquote><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>对于最小公倍数的计算，我们首先可以基于gcd的基础得到一个简单的算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b/<span class="built_in">gcd</span>(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以根据上文的约数分解逆推出求其最小公倍数的公式，我们知道如果某个数a含有约数b，那么数a的倍数也含有这个约数b，因此有结论：</p><blockquote><p>最小公倍数等于各个数字分解而成的各个质数在所有数字中最大幂次的积。</p></blockquote><h2 id="大数运算"><a href="#大数运算" class="headerlink" title="大数运算"></a>大数运算</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原本打算将这篇博客取名数论基础，然而想想实在狂妄，本文仅仅记录了一些在做编程题时可能会用到的数学方法，离正统的数论还相差甚远，就数论杂记一名</summary>
      
    
    
    
    <category term="杂项" scheme="https://gitee.com/cloudstill/cloudstill.git/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="C++" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/C/"/>
    
    <category term="数论" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构_05：栈</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-05%EF%BC%9A%E6%A0%88/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-05%EF%BC%9A%E6%A0%88/</id>
    <published>2023-02-07T07:56:39.000Z</published>
    <updated>2023-02-07T14:43:05.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><p>汉语中对栈字的解释是存储货物或供旅客住宿的房屋，对应的，在计算机中栈指的是数据暂时存储的地方。<br>栈的特点，就像我们玩的俄罗斯方块一样，我们只能在最顶部进行操作。对此，我们总结为先进后出、后进先出。<br>对此，我们可以有流程图便于理解：<br><img src="1.jpg"></p><h2 id="顺序表实现栈"><a href="#顺序表实现栈" class="headerlink" title="顺序表实现栈"></a>顺序表实现栈</h2><p>栈的实现可以基于顺序表或是链表，这里我们先用顺序表实现，这里我们需要实现两个新的功能：</p><ol><li>入栈（push）：入栈操作，向栈中压入一个新的元素；</li><li>出栈（pop）：出栈操作，从栈顶取出一个元素。</li></ol><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>这里我们基于顺序表设计，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span>* <span class="built_in">array</span>;</span><br><span class="line">  <span class="type">int</span> capacity;</span><br><span class="line">  <span class="type">int</span> top;<span class="comment">//当前的栈顶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这里我们基于顺序表设计，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>* <span class="title">arraystack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setupstack</span><span class="params">(arraystack stack_)</span></span><br><span class="line">&#123;</span><br><span class="line">  stack_-&gt;<span class="built_in">array</span>=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);<span class="comment">//初始容量为10</span></span><br><span class="line">  <span class="keyword">if</span>(stack_-&gt;<span class="built_in">array</span>==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    stack_-&gt;capacity=<span class="number">10</span>;</span><br><span class="line">    stack_-&gt;top=<span class="number">-1</span>;<span class="comment">//由于没有元素，栈顶默认为-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>在正式开始设计入栈功能之前，我们可以预料到在入栈时可能会产生容量不够的情况，故我们可以先设计扩容功能，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">extendstack</span><span class="params">(arraystack stack_)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> newcapacity=stack_-&gt;capacity*<span class="number">2</span>;<span class="comment">//内存扩展两倍</span></span><br><span class="line">  <span class="type">int</span>* newarray=<span class="built_in">realloc</span>(stack_-&gt;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)*newcapacity);</span><br><span class="line">  <span class="keyword">if</span>(newarray==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  stack_-&gt;<span class="built_in">array</span>=newarray;</span><br><span class="line">  stack_-&gt;capacity=newcapacity;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><p>由于栈只能从尾部插入，所以入栈操作实现起来非常简单，同时我们需要用上刚刚设计好的扩容，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pushstack</span><span class="params">(arraystack satck_, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(stack_-&gt;top+<span class="number">1</span>==<span class="built_in">stack</span>-&gt;capacity)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!extendstack(stack_))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  stack_-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;top+<span class="number">1</span>]=element;</span><br><span class="line">  stack_-&gt;top++;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p>在出栈之前，我们需要判断一下栈是否为空，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isempty</span><span class="params">(arraystack stack_)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!stack_-&gt;+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//为空时返回0，不为空时返回1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><p>出栈操作便更加简单了，只需要将栈顶元素取出即可，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">popstack</span><span class="params">(arraystack stack_)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> stack_-&gt;<span class="built_in">array</span>[stack_-&gt;top--]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p>为了提高栈的利用率，我们可以将一个固定长度的数组共享给两个栈来使用，将数组的两头作为两个栈的栈底，当两个栈的栈顶想要时表示栈已满。</p><h2 id="链表实现栈"><a href="#链表实现栈" class="headerlink" title="链表实现栈"></a>链表实现栈</h2><p>在上文中我们介绍了用顺序表实现栈，然而在实际中，使用链表来实现栈会显得更加方便。<br>我们规定链表表头指向栈顶，而栈顶指向后续的元素直至栈底。<br>每当有新的元素入栈，我们只需要在链表头部插入新的结点即可。</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>有链表作为基础，我们可以很容易初始化，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> element;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setuplist</span><span class="params">(Node head)</span></span><br><span class="line">&#123;</span><br><span class="line">  head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h3><p>有链表作为基础，我们可以很容易的入栈，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pushstack</span><span class="params">(Node head, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">  Node node=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> listnode));</span><br><span class="line">  <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  node-&gt;next=head-&gt;next;</span><br><span class="line">  node-&gt;element=element;</span><br><span class="line">  head-&gt;next=node;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空-1"><a href="#判空-1" class="headerlink" title="判空"></a>判空</h3><p>在出栈之前我们需要判断栈是否为空，和链表类似的，我们只需要看头结点即可，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isempty</span><span class="params">(Node head)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h3><p>有上文和链表作为基础，我们可以很容易实现出栈，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">popstack</span><span class="params">(Node head)</span></span><br><span class="line">&#123;</span><br><span class="line">  Node top=head-&gt;next;</span><br><span class="line">  head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">  <span class="type">int</span> tmp=top-&gt;element;</span><br><span class="line">  <span class="built_in">free</span>(top);</span><br><span class="line">  top=NUll;</span><br><span class="line">  <span class="keyword">return</span> tmp;<span class="comment">//返回栈顶元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>栈本质上是基于前面所说的两种线性表的一种特殊线性表，有前面的学习作为基础，在学习时并不会产生多大困难。<br>相似的，下一节所讲的队列也是一种特殊的线性表。</p><h2 id="返回目录"><a href="#返回目录" class="headerlink" title="返回目录"></a>返回目录</h2><p>你可以<a href="/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01%EF%BC%9A%E6%A6%82%E8%AE%BA/" title="点击此处">点击此处</a>返回或查看目录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;栈的概念&quot;&gt;&lt;a href=&quot;#栈的概念&quot; class=&quot;headerlink&quot; title=&quot;栈的概念&quot;&gt;&lt;/a&gt;栈的概念&lt;/h2&gt;&lt;p&gt;汉语中对栈字的解释是存储货物或供旅客住宿的房屋，对应的，在计算机中栈指的是数据暂时存储的地方。&lt;br&gt;栈的特点，就像我们玩的</summary>
      
    
    
    
    <category term="数据结构" scheme="https://gitee.com/cloudstill/cloudstill.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C语言" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="教程" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构_04：特殊链表</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-04%EF%BC%9A%E7%89%B9%E6%AE%8A%E9%93%BE%E8%A1%A8/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-04%EF%BC%9A%E7%89%B9%E6%AE%8A%E9%93%BE%E8%A1%A8/</id>
    <published>2023-02-06T16:56:15.000Z</published>
    <updated>2023-02-07T08:29:39.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>在单链表，也就是上一节提到的普通链表中，当我们需要完成插入或者删除操作时，我们通常需要找到需要操作的链结的上一个链结，为了解决这个问题，双向链表应运而生。双向链表的结构如下图所示：<br><img src="1.jpg"><br>基于双向链表的不同结构，我们需要对定义结构体，初始化，插入和删除功能进行更新，而其他功能的实现则与单链表相同。</p><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>对于双向链表需要指向前一个链结的功能，我们需要在结构体中添加一个结构体指针变量来指向前一个结点，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> element;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于已经有了单链表基础，对于定义结构体此处不再过多赘述。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>双向链表在初始化时只需要将前链也设置为NULL即可，其余的和本教程中单链表一样，在初始化时仅对头链结进行进行初始化，同时对结构体指针重命名以便于后续操作，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setuphead</span><span class="params">(Node headnode)</span></span><br><span class="line">&#123;</span><br><span class="line">  headnode=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> listnode));</span><br><span class="line">  headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  headnode-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>和单链表不同的是，双向链表在插入时需要操作的链更多，这里我们依然用一个流程图来解释全过程：<br><img src="2.jpg"><br>基于此流程图，我们可以设计出一下代码，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertlist</span><span class="params">(Node head, <span class="type">int</span> element, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(--index)</span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;<span class="comment">//向后寻找到插入结点的前结点</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="comment">//插入位置非法</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node node=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> listnode));<span class="comment">//新建一个链结并为其申请内存</span></span><br><span class="line">  <span class="keyword">if</span>(node==<span class="literal">NULL</span>)<span class="comment">//判断申请内存是否失败，失败返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  node-&gt;element=element;</span><br><span class="line">  <span class="keyword">if</span>(head-&gt;next)<span class="comment">//先处理后结点，若存在</span></span><br><span class="line">  &#123;</span><br><span class="line">    node-&gt;next=head-&gt;next;</span><br><span class="line">    head-&gt;next-&gt;prev=node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//若后结点不存在</span></span><br><span class="line">  &#123;</span><br><span class="line">    node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  head-&gt;next=node;<span class="comment">//操作前结点</span></span><br><span class="line">  node-&gt;prev=head;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再完成这一系列操作后，我们可以将其正向反向分别遍历一遍以测试效果。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除操作相较于插入较为简单，先看流程图：<br><img src="3.jpg"><br>据此，我们很容易设计出代码，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deletelist</span><span class="params">(Node head, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index &lt; <span class="number">1</span>)<span class="comment">//先找到位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(--index)</span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  Node tmp=head-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(head-&gt;next-&gt;next)<span class="comment">//删除非尾结点</span></span><br><span class="line">  &#123;</span><br><span class="line">    head-&gt;next-&gt;next-&gt;prev=head;</span><br><span class="line">    head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;<span class="comment">//删除尾结点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(tmp);</span><br><span class="line">  tmp=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向链表的其他操作与单链表大致相同，这里就不做介绍了。</p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>相对于普通链表，循环链表多了一个尾结点指向头结点的链，这样的链表从任意结点出发都可以达到任意结点，结构如下图所示：<br><img src="4.jpg"><br>循环链表的代码较为简单，仅仅需要在普通链表的基础上将尾结点指向头结点即可，这里不做赘述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>双向链表和循环链表本质上还是链表，它们只是链表为了适应不同环境的产物，这也就启发我们在实际运用数据结构时也要根据实际情况进行变化。</p><h2 id="返回目录"><a href="#返回目录" class="headerlink" title="返回目录"></a>返回目录</h2><p>你可以<a href="/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01%EF%BC%9A%E6%A6%82%E8%AE%BA/" title="点击此处">点击此处</a>返回或查看目录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;双向链表&quot;&gt;&lt;a href=&quot;#双向链表&quot; class=&quot;headerlink&quot; title=&quot;双向链表&quot;&gt;&lt;/a&gt;双向链表&lt;/h2&gt;&lt;p&gt;在单链表，也就是上一节提到的普通链表中，当我们需要完成插入或者删除操作时，我们通常需要找到需要操作的链结的上一个链结，为了解</summary>
      
    
    
    
    <category term="数据结构" scheme="https://gitee.com/cloudstill/cloudstill.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C语言" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="教程" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构_03：链表</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-03%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-03%EF%BC%9A%E9%93%BE%E8%A1%A8/</id>
    <published>2023-01-13T09:22:34.000Z</published>
    <updated>2023-09-26T07:53:05.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链，是一种什么样的东西呢？现实生活中我们都见过铁链金链和银链，它们都有一个特点，是一个环节一个环节环环相扣连接在一起的。而链表，则是一种具有相似结构的数据结构。<br>在链表中，每一个环节，即链结，都需要负责实现两个功能：</p><ol><li>记录某些数值；</li><li>指向下一链结。</li></ol><p>一般而言，链表可以分为两种，一种头链结为空仅指向第二个链结，另一种头链结不为空。这里我们只介绍前面一种。</p><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>在此之前我们已经达成了对于链结功能的共识，为了方便我们将每一个小的链结都定义成一个结构体，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> element;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个结构体中，我们定义了两个成员整型变量element和结构体指针变量next。其中，element负责执行第一个功能，记录某些数值，而next负责指向下一个链结。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>网上很多教程在初始化时会提前预想可能的链结个数，本教程奉行即插即建即用原则，在初始化时仅对头链结进行进行初始化。和顺序表一样，我们可以用typedef函数将结构体指针重命名以便于后续操作，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setuphead</span><span class="params">(Node headnode)</span></span><br><span class="line">&#123;</span><br><span class="line">  headnode=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> listnode));</span><br><span class="line">  headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，我们用malloc()函数为头链结申请了一块空间，接着保证不指向其他链结。</p><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p>有时我们需要判断一个链表是否为空，根据链表的性质，我们只需要判断头链结是否指向其他链结即可，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">emptylist</span><span class="params">(Node headnode)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(headnode-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为空，1为非空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>和链子一样，链表的插入只需要将插入项与理论上的下一链结连接，再将原来连接这一链结的前一链结链接插入项即可。<br>这个过程描述起来有些抽象，其实很多人对链表这个概念到现在都很模糊，无妨，且看下面的流程图：<br><img src="pic.jpg"><br>在上述流程图中，我们我们表明了链结的序号，其中，序号0即为头链结。<br>至此我们已经知道了链表插入的操作流程，接下来我们就可以写程序来实现这个功能了，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertlist</span><span class="params">(Node head, <span class="type">int</span> element, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(--index)</span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;<span class="comment">//向后寻找到插入结点的前结点</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)<span class="comment">//插入位置非法</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node node=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> listnode));<span class="comment">//新建一个链结并为其申请内存</span></span><br><span class="line">  <span class="keyword">if</span>(node==<span class="literal">NULL</span>)<span class="comment">//判断申请内存是否失败，失败返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  node-&gt;element=element;</span><br><span class="line">  node-&gt;next=head-&gt;next;</span><br><span class="line">  head-&gt;next=node;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>与插入相似的，从链表中删除一个元素只需要断开该元素与指向这个元素的链结之间的联系，并且将指向该元素的链结指向该元素指向的链结。<br>乍一听可能有些抽象，这里我们同样用一个流程图来表述：<br><img src="pic1.jpg"><br>通过该流程图，我们可以很好地理解删除的全过程，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deletelist</span><span class="params">(Node head, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(--index)</span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  Node tmp=head-&gt;next;</span><br><span class="line">  head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">  <span class="built_in">free</span>(tmp);</span><br><span class="line">  tmp=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找长度"><a href="#查找长度" class="headerlink" title="查找长度"></a>查找长度</h3><p>和顺序表不一样的是，我们在构建链表结构体时并没有引入一个变量来表示链表的长度，但是根据链表的定义，我们可以很容易地知道，一个链表的最后一个链结并不指向其他链结，所以我们只需要从头开始遍历整个链表，找到那个特殊的链结即可，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sizelist</span><span class="params">(Node head)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(head)</span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>在查找元素这个操作中，我们可以很容易采取遍历查找的方式来实现，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findlist</span><span class="params">(Node head, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">  head=head-&gt;next;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(head)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;element==element)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找索引"><a href="#查找索引" class="headerlink" title="查找索引"></a>查找索引</h3><p>和顺序表不一样的是，我们在定义链表结构体时并没有引入索引这一变量，这也就导致了我们在查找索引时必须要从表头开始查找，因而在执行查找索引这一操作上链表的效率低于顺序表。<br>我们可以很容易地用遍历的方法来实现查找索引的功能，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">getlist</span><span class="params">(Node head, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(--index);</span><br><span class="line">  <span class="keyword">return</span> &amp;head-&gt;element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>当我们想要实现打印链表功能时，我们只需要从头开始边遍历整个链表边打印元素直至链结不再指向下一链结为止，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printlist</span><span class="params">(Node head)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(head-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,head-&gt;element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序表与链表的区别"><a href="#顺序表与链表的区别" class="headerlink" title="顺序表与链表的区别"></a>顺序表与链表的区别</h2><p>如果我们深入思考了上一节中讲的顺序表，我们会发现它在一定程度上和数组十分相似，并且它在存储时也是一段连续的内存，而本节所讲的链表是不连续存储的。<br>在我们日常生活中，有时会遇到顺序表和链表如何抉择的问题。一个数据结构往往要实现增删查改四个功能。其实，当我们仔细比较其优缺点后，我们很容易发现顺序表在查改方面存在优势，而链表在增删方面存在优势。这也就意味着，当我们实际使用时，可以根据所用的次数来决定如何选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链表作为一个经典的数据结构，在学习上会存在着一定的难度。但是，有了前面顺序表的基础，再加上认真钻研，实际理解起来还是很简单的。<br>值得注意的是，数据结构并不是一门基于某某语言的课程，实际上，我们可以用任何语言来写数据结构。同时，即便是同种语言下的数据结构，在实现起来也会存在代码的不同，本教程仅仅提供一种解决方案。<br>我们在学习时，一定不要局限于形式上的不同，关键要领略其核心思想，勤于思考才能事半功倍。</p><h3 id="附代码"><a href="#附代码" class="headerlink" title="附代码"></a>附代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> element;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>* <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setuphead</span><span class="params">(Node headnode)</span></span><br><span class="line">&#123;</span><br><span class="line">  headnode=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> listnode));</span><br><span class="line">  headnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">emptylist</span><span class="params">(Node headnode)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(headnode-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为空，1为非空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertlist</span><span class="params">(Node head, <span class="type">int</span> element, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(--index)</span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node node=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> listnode));</span><br><span class="line">  <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  node-&gt;element=element;</span><br><span class="line">  node-&gt;next=head-&gt;next;</span><br><span class="line">  head-&gt;next=node;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletelist</span><span class="params">(Node head, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(--index)</span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  Node tmp=head-&gt;next;</span><br><span class="line">  head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">  <span class="built_in">free</span>(tmp);</span><br><span class="line">  tmp=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sizelist</span><span class="params">(Node head)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(head)</span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findlist</span><span class="params">(Node head, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">  head=head-&gt;next;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(head)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;element==element)</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getlist</span><span class="params">(Node head, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(--index);</span><br><span class="line">  <span class="keyword">return</span> &amp;head-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printlist</span><span class="params">(Node head)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(head-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,head-&gt;element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本教程参考资料如下：</p><ul><li>B站视频：<br><a class="link" href="https://www.bilibili.com/video/BV13W4y127Ey/?p=8&share_source=copy_web&vd_source=53065aea9ac10aafe4148aca8749443c">《数据结构与算法 已完结（CLion 2022 最新版）4K蓝光画质+杜比音效 全程高能》<i class="fas fa-external-link-alt"></i></a><br><a class="link" href="https://www.bilibili.com/video/BV1Fv4y1f7T1/?p=5&share_source=copy_web&vd_source=53065aea9ac10aafe4148aca8749443c">《【强烈推荐】深入浅出数据结构 - 顶尖程序员图文讲解 - UP主翻译校对 (已完结)》<i class="fas fa-external-link-alt"></i></a></li><li>CSDN文章：<br><a class="link" href="http://t.csdn.cn/xwPpA">《c语言链表详解（超详细）》<i class="fas fa-external-link-alt"></i></a><br><a class="link" href="http://t.csdn.cn/KuU8c">《关于链表，看这一篇就够了！（新手入门）》<i class="fas fa-external-link-alt"></i></a><br><a class="link" href="http://t.csdn.cn/80UTU">《链表(开辟和不开辟新空间)》<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="返回目录"><a href="#返回目录" class="headerlink" title="返回目录"></a>返回目录</h2><p>你可以<a href="/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01%EF%BC%9A%E6%A6%82%E8%AE%BA/" title="点击此处">点击此处</a>返回或查看目录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;p&gt;链，是一种什么样的东西呢？现实生活中我们都见过铁链金链和银链，它们都有一个特点，是一个环节一个环节环环相扣连接在一起的。而链表，则是一种具有</summary>
      
    
    
    
    <category term="数据结构" scheme="https://gitee.com/cloudstill/cloudstill.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C语言" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="教程" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构_02：顺序表</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2023/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2023/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8/</id>
    <published>2023-01-10T15:21:20.000Z</published>
    <updated>2023-02-07T14:43:11.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组和表的区别"><a href="#数组和表的区别" class="headerlink" title="数组和表的区别"></a>数组和表的区别</h2><p>在开启本教程学习之前，相信大家已经有了一定语言基础，对于数组，大家一定十分熟悉。我们在使用数组时，或多或少会遇到以下几个问题：</p><ol><li>必须在一开始就声明数组的长度；</li><li>无法随时随用地对数组进行扩容，这就导致了一开始声明的数组的长度必须足够大；</li><li>可能会存在未使用的数组，这对内存是一种浪费。</li></ol><p>而表，就是一种可以解决这些问题的数据结构。<br>关于数组和表，更多的区别需要可能会涉及一些更加深层的知识，这里不做赘述，欢迎自己探知。</p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>按照惯例，我们一般需要对顺序表进行一定的介绍：顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。<br>为了方便理解，我们可以简单地认为他是一种可以动态变化的连续存储的数组。</p><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>顺序表的实现有很多方式，其中，我们采取结构体的方式。<br>首先我们需要定义一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span>* <span class="built_in">array</span>;</span><br><span class="line">  <span class="type">int</span> capacity;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们定义了一个叫list的结构体，它包含了三个成员，整型指针变量array，整型变量capacity和整型变量size。<br>和它们的名字一样，array表示顺序表所占的内存空间，capacity表示顺序表的理论最大容量，size表示顺序表中已经填满的容量，即实际长度。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>当我们定义完结构体后，我们还没有真正创建一个顺序表，即便我们在main函数中创建了一个结构体变量，它也不能真正算得上一个顺序表。<br>一个顺序表的实现必须要对其进行初始化，为了便于多次使用，我们采取自定义一个初始化函数的方式实现。<br>在此之前，为了便于后续操作，我们可以使用typedef函数将结构体指针<code>struct list*</code>重命名为<code>arraylist</code>，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>* <span class="title">arraylist</span>;</span></span><br></pre></td></tr></table></figure><p>此后涉及<code>struct list*</code>的内容我们一律用<code>arraylist</code>代替，请根据需求自行代换。<br>根据我们此前定义的结构体的三个成员内存array，容量capacity，长度size，我们可以设想到初始化需要进行的操作。<br>我们都知道计算机在存储数据时需要用到内存空间，所以我们在初始化时，需要使用malloc()函数申请一块内存空间，使用此函数前我们需要引入新的头文件&lt;stdlib.h&gt;，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>接着，我们需要用变量表示顺序表初始的最大容量和实际长度。<br>综上，初始化一个顺序表需要实现以下三个功能：</p><ol><li>向计算机申请一块内存空间；</li><li>表示顺序表初始最大容量；</li><li>表示顺序表初始实际长度，即0；</li></ol><p>实现这三个功能并不难，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setuplist</span><span class="params">(arraylist <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">list</span>-&gt;capacity=<span class="number">1</span>;<span class="comment">//此处初始化顺序表容量为1，实际可更改</span></span><br><span class="line">  <span class="built_in">list</span>-&gt;<span class="built_in">array</span>=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="built_in">list</span>-&gt;capacity);</span><br><span class="line">  <span class="built_in">list</span>-&gt;size=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码块，有几点值得我们注意：</p><ol><li>在学习函数章节时，我们已经知道了函数传值和传地址的区别，此处由于我们需要对顺序表地址进行操作，故需要用到结构体指针；</li><li>表示结构体指针的成员需要用到-&gt;符号，或者也可以用(*指针名).成员名表示；</li><li>sizeof()函数会根据括号内的数据类型换算成对应的内存大小；</li></ol><p>当我们深入了解malloc()函数后，我们会知道有时malloc()函数也会申请内存失败，此时它会返回NULL，同时申请失败也就意味着初始化失败，我们可以采取一种方式来表示初始化的成功与否。<br>我们可以用布尔型返回true和false来表示初始化的结果，但是我们都知道true&#x3D;1，false&#x3D;0，又因为C语言中可能存在没有布尔型的情况，此处我们仅仅展示一个在部分C语言标准下存在的代码块，后续涉及判断内容我们一律采用int型，代码块即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">_Bool</span> test_1=<span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> test_2=<span class="literal">false</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于增加判断申请内存失败与否的初始化函数，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setuplist</span><span class="params">(arraylist <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">list</span>-&gt;capacity=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">list</span>-&gt;<span class="built_in">array</span>=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="built_in">list</span>-&gt;capacity);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">list</span>-&gt;size=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们已经实现了顺序表的初始化功能。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当我们初始化一个顺序表后，有时我们会面临最大容量不足的情况，当然我们一开始初始化的可以很容易的保证最大容量足够第一次使用，可是当我们后续使用时，有时要对其进行扩容。<br>在C语言中本身提供了realloc()函数重新申请一块内存，和malloc()一样，它也是包含于&lt;stdlib.h&gt;头文件中的，扩容的操作极其简单，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">extendlist</span><span class="params">(arraylist <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> newcapacity=<span class="built_in">list</span>-&gt;capacity*<span class="number">2</span>;<span class="comment">//内存扩展两倍</span></span><br><span class="line">  <span class="type">int</span>* newarray=<span class="built_in">realloc</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)*newcapacity);</span><br><span class="line">  <span class="keyword">if</span>(newarray==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">list</span>-&gt;<span class="built_in">array</span>=newarray;</span><br><span class="line">  <span class="built_in">list</span>-&gt;capacity=newcapacity;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>一个顺序表被创建出来后，其中并没有元素，这时我们可以对其进行插入。和插入数组一样，我们顺序表的插入也需要三个要素：</p><ol><li>被插入的顺序表；</li><li>插入的数字；</li><li>插入的位置。</li></ol><p>基于此，我们很容易就可以设计出一个插入顺序表的函数，在我们正式开始进行写代码前，我们可以很容易的预见一些插入过程中可能会发生的问题：</p><ol><li>插入的位置在可插入的位置之外；</li><li>顺序表容积已满，需要扩容；</li><li>如何选择插入的方法。</li></ol><p>关于第一个问题，我们一般认为顺序表从的位置从1开始，那么当我们插入的位置小于1或很大时，这个插入是不可取的；关于第二个问题，我们只需要在插入过程中引入if判断是否需要扩容即可；关于第三个问题，我们可以很容易想到，我们只需要将顺序表的元素从尾部开始依次向后移动一位直到空出需要插入的位置，再将需要插入的元素插入需要插入的位置即可。<br>综上，我们可以很容易写出代码，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertlist</span><span class="params">(arraylist <span class="built_in">list</span>, <span class="type">int</span> element, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>||index&gt;<span class="built_in">list</span>-&gt;size+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="built_in">list</span>-&gt;capacity)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!extendlist(arraylist <span class="built_in">list</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="built_in">list</span>-&gt;size; i&gt;index<span class="number">-1</span>; i--)</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i]=<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i<span class="number">-1</span>];</span><br><span class="line">  <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index<span class="number">-1</span>]=element;</span><br><span class="line">  <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>当我们学会了插入后，再学习删除是非常简单的，我们只需要根据位置信息，就可以将顺序表中的某个元素删除，值得注意是，输入的位置信息也需要在合法的范围内，代码即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deletelist</span><span class="params">(arraylist <span class="built_in">list</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>||index&gt;<span class="built_in">list</span>-&gt;size)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=index<span class="number">-1</span>; i&lt;<span class="built_in">list</span>-&gt;size; i++)</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i]=<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找长度"><a href="#查找长度" class="headerlink" title="查找长度"></a>查找长度</h3><p>查找长度相当简单，我们只需要向主程序返回size值即可，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sizelist</span><span class="params">(<span class="built_in">array</span> <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>查找元素也同样简单，我们可以选择多种查找方式，这里我们采用简单的遍历查找，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findlist</span><span class="params">(arraylist <span class="built_in">list</span>, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="built_in">list</span>-&gt;size; i++)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i]==element)</span><br><span class="line">      <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//数组从0开始，顺序表从1开始，故i+1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找索引"><a href="#查找索引" class="headerlink" title="查找索引"></a>查找索引</h3><p>查找索引即查找某个位置上对应元素的值，有了上述模块的经验，我们很容易设计出一个功能齐全的函数，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">getlist</span><span class="params">(arraylist <span class="built_in">list</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>||index&gt;<span class="built_in">list</span>-&gt;size)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index<span class="number">-1</span>];<span class="comment">//注意数组索引和顺序表索引的区别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>打印顺序表索引元素的函数也同样简单，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printlist</span><span class="params">(arraylist <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="built_in">list</span>-&gt;size; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>当我们使用完顺序表后，有时候需要销毁它释放内存，此时我们可以用free()函数来进行操作，free()函数必须与malloc()函数配套使用，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">destorylist</span><span class="params">(arraylist <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">free</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>);</span><br><span class="line">  <span class="built_in">list</span>-&gt;<span class="built_in">array</span>=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">list</span>-capacity=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">list</span>-&gt;size=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顺序表作为数据结构的第一节，并不算难，我们关键是要从中领会思想，学习一些函数的用法，为接下来链表的学习打好基础。</p><h3 id="附代码"><a href="#附代码" class="headerlink" title="附代码"></a>附代码</h3><p>全代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span>* <span class="built_in">array</span>;</span><br><span class="line">  <span class="type">int</span> capacity;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>* <span class="title">arraylist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setuplist</span><span class="params">(arraylist <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">list</span>-&gt;capacity=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">list</span>-&gt;<span class="built_in">array</span>=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="built_in">list</span>-&gt;capacity);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">list</span>-&gt;size=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">extendlist</span><span class="params">(arraylist <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> newcapacity=<span class="built_in">list</span>-&gt;capacity*<span class="number">2</span>;<span class="comment">//内存扩展两倍</span></span><br><span class="line">  <span class="type">int</span>* newarray=<span class="built_in">realloc</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)*newcapacity);</span><br><span class="line">  <span class="keyword">if</span>(newarray==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">list</span>-&gt;<span class="built_in">array</span>=newarray;</span><br><span class="line">  <span class="built_in">list</span>-&gt;capacity=newcapacity;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertlist</span><span class="params">(arraylist <span class="built_in">list</span>, <span class="type">int</span> element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>||index&gt;<span class="built_in">list</span>-&gt;size+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size==<span class="built_in">list</span>-&gt;capacity)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!extendlist(arraylist <span class="built_in">list</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="built_in">list</span>-&gt;size;i&gt;index<span class="number">-1</span>;--i)</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i]=<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i<span class="number">-1</span>];</span><br><span class="line">  <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index<span class="number">-1</span>]=element;</span><br><span class="line">  <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletelist</span><span class="params">(arraylist <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>||index&gt;<span class="built_in">list</span>-&gt;size)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=index<span class="number">-1</span>; i&lt;<span class="built_in">list</span>-&gt;size; i++)</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i]=<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sizelist</span><span class="params">(arraylist <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findlist</span><span class="params">(arraylist <span class="built_in">list</span>, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="built_in">list</span>-&gt;size; i++)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i]==element)</span><br><span class="line">      <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getlist</span><span class="params">(arraylist <span class="built_in">list</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">1</span>||index&gt;<span class="built_in">list</span>-&gt;size)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printlist</span><span class="params">(arraylist <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="built_in">list</span>-&gt;size; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">destorylist</span><span class="params">(arraylist <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">free</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>);</span><br><span class="line">  <span class="built_in">list</span>-&gt;<span class="built_in">array</span>=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">list</span>-capacity=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">list</span>-&gt;size=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回目录"><a href="#返回目录" class="headerlink" title="返回目录"></a>返回目录</h2><p>你可以<a href="/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01%EF%BC%9A%E6%A6%82%E8%AE%BA/" title="点击此处">点击此处</a>返回或查看目录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组和表的区别&quot;&gt;&lt;a href=&quot;#数组和表的区别&quot; class=&quot;headerlink&quot; title=&quot;数组和表的区别&quot;&gt;&lt;/a&gt;数组和表的区别&lt;/h2&gt;&lt;p&gt;在开启本教程学习之前，相信大家已经有了一定语言基础，对于数组，大家一定十分熟悉。我们在使用数组时，或</summary>
      
    
    
    
    <category term="数据结构" scheme="https://gitee.com/cloudstill/cloudstill.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C语言" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="教程" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>评教教程</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2022/12/14/%E8%AF%84%E6%95%99%E6%95%99%E7%A8%8B/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2022/12/14/%E8%AF%84%E6%95%99%E6%95%99%E7%A8%8B/</id>
    <published>2022-12-14T04:23:43.000Z</published>
    <updated>2023-01-29T17:30:03.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Edge评教流程"><a href="#Edge评教流程" class="headerlink" title="Edge评教流程"></a>Edge评教流程</h2><p>首先打开网址<a class="link" href="https://webvpn.wbu.edu.cn/">webvpn.wbu.edu.cn<i class="fas fa-external-link-alt"></i></a>，然后不要着急输入账密，按照以下流程操作：</p><ol><li>右上角打开设置,点击默认浏览器：<br><img src="1.png"><br>如果上述没有成功，你也可以这样操作：<br><img src="1.5.png"></li><li>开启允许打开IE兼容模式后，我们还要点击右上角设置把IE兼容模式打开：<br><img src="2.jpg"><br>如果你在第一步中选择了第二种方式，此时你可以：<br><img src="2.5.png"></li><li>完成了上述步骤后就可以输入密码了，后面的步骤非常简单<br><img src="3.png"><br><img src="4.png"><br><img src="5.png"></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>评教时不可以全打一样的分，也就是说最高打93分。</li><li>直接提交后可能会发现还是显示的0分，但是再进去就会发现已经有分了。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Edge评教流程&quot;&gt;&lt;a href=&quot;#Edge评教流程&quot; class=&quot;headerlink&quot; title=&quot;Edge评教流程&quot;&gt;&lt;/a&gt;Edge评教流程&lt;/h2&gt;&lt;p&gt;首先打开网址&lt;a class=&quot;link&quot; href=&quot;https://webvpn.wbu</summary>
      
    
    
    
    <category term="教程" scheme="https://gitee.com/cloudstill/cloudstill.git/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="教程" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C语言教程_06：判断语句二三事</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2022/12/12/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B-06%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2022/12/12/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B-06%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E4%BA%8C%E4%B8%89%E4%BA%8B/</id>
    <published>2022-12-12T04:09:49.000Z</published>
    <updated>2023-09-26T07:53:03.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if相信大家都不陌生，在英文中它有着“如果”的意思，它引导的条件状语从句可以翻译为“如果……就……”，而在C语言中，它也有着相同的用法，且看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(......)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>套用英语中的逻辑来理解这个例子，把它翻译成中文就是“如果小括号里面的内容成立，那么花括号里面的内容也成立”。<br>小括号里面可以填什么呢？数字，变量，表达式，关系式都可以。<br>对于数字和变量，在计算机中，无论它们的值是多少，都只有0和非0的区别，非0又可以理解为1。我们都知道在计算机中0表示假，1表示真。即小括号里的数字和变量如果为0，语句不成立，为1（非0）则成立。<br>对于表达式，程序会先将其进行运算之后，再对其数值进行如对数字和变量相同的操作。<br>对于关系式，它们同样遵循01原则，当关系式成立时它们相当于1，当关系式不成立时它们相当于0。<br>说完小括号我们再来说说花括号，花括号里填写的是函数语句，函数语句的成立意味着执行，这也就是说，一旦小括号里的值为1，那么就会执行花括号里的内容。<br>尽管以上方式极易理解，但需要声明的是括号中的内容实际上会进行一次隐式类型转换，即根据表达式的成立与否转换为true或者false。</p><h2 id="if与else不得不说的故事"><a href="#if与else不得不说的故事" class="headerlink" title="if与else不得不说的故事"></a>if与else不得不说的故事</h2><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;if语句&quot;&gt;&lt;a href=&quot;#if语句&quot; class=&quot;headerlink&quot; title=&quot;if语句&quot;&gt;&lt;/a&gt;if语句&lt;/h2&gt;&lt;p&gt;if相信大家都不陌生，在英文中它有着“如果”的意思，它引导的条件状语从句可以翻译为“如果……就……”，而在C语言中，它也有着</summary>
      
    
    
    
    <category term="C语言教程" scheme="https://gitee.com/cloudstill/cloudstill.git/categories/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="教程" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构_01：概论</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01%EF%BC%9A%E6%A6%82%E8%AE%BA/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01%EF%BC%9A%E6%A6%82%E8%AE%BA/</id>
    <published>2022-12-12T03:58:19.000Z</published>
    <updated>2023-08-04T15:39:32.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>一般来说，用计算机解决一个具体问题时，大致需要经过下列几个步骤：首先要从具体问题抽象出一个适当的数学模型，然后设计一个解此数学模型的算法，最后编出程序，进行测试、调整直至得到最终解答。寻求数学模型的实质是分析问题，从中提取操作的对象，并找出这些操作对象之间含有的关系，然后用数学的语言加以描述。例如，求解梁架结构中应力的数学模型为线性方程组；预报人口增长情况的数学模型为微分方程。然而，更多的非数值计算问题无法用数学方程加以描述。<br>在生活中随处可见这样的例子，如图书馆数目检索系统自动化问题，计算机和人对弈问题，多叉路口交通灯的管理问题等等。在这三个例子中，我们描述问题的数学模型是称为“表”“树“和”图“的数据结构而非一个简单的数学方程。<br>因此，简单来说，数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等的学科。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="/2023/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8/" title="顺序表">顺序表</a></li><li><a href="/2023/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-03%EF%BC%9A%E9%93%BE%E8%A1%A8/" title="链表">链表</a></li><li><a href="/2023/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-04%EF%BC%9A%E7%89%B9%E6%AE%8A%E9%93%BE%E8%A1%A8/" title="特殊链表">特殊链表</a></li><li><a href="/2023/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-05%EF%BC%9A%E6%A0%88/" title="栈">栈</a></li><li><a href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-06%EF%BC%9A%E9%98%9F%E5%88%97/" title="队列（未更新）">队列（未更新）</a></li><li><a href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-07%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9E%E6%88%98/" title="线性表实战（未更新）">线性表实战（未更新）</a></li><li><a href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-08%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树（未更新）">二叉树（未更新）</a></li><li><a href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-09%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%A0%91/" title="高级树（未更新）">高级树（未更新）</a></li><li><a href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-10%EF%BC%9A%E5%85%B6%E4%BB%96%E6%A0%91/" title="其他树（未更新）">其他树（未更新）</a></li><li><a href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-11%EF%BC%9A%E6%A0%91%E5%AE%9E%E6%88%98/" title="树实战（未更新）">树实战（未更新）</a></li><li><a href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-12%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/" title="散列表（未更新）">散列表（未更新）</a></li><li><a href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-13%EF%BC%9A%E5%9B%BE/" title="图（未更新）">图（未更新）</a></li><li><a href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-14%EF%BC%9A%E5%9B%BE%E5%BA%94%E7%94%A8/" title="图应用（未更新）">图应用（未更新）</a></li><li><a href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-15%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="排序算法（未更新）">排序算法（未更新）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是数据结构&quot;&gt;&lt;a href=&quot;#什么是数据结构&quot; class=&quot;headerlink&quot; title=&quot;什么是数据结构&quot;&gt;&lt;/a&gt;什么是数据结构&lt;/h2&gt;&lt;p&gt;一般来说，用计算机解决一个具体问题时，大致需要经过下列几个步骤：首先要从具体问题抽象出一个适当的数学</summary>
      
    
    
    
    <category term="数据结构" scheme="https://gitee.com/cloudstill/cloudstill.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C语言" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="教程" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C语言教程_05：输入与输出</title>
    <link href="https://gitee.com/cloudstill/cloudstill.git/2022/10/20/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B-05%EF%BC%9A%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
    <id>https://gitee.com/cloudstill/cloudstill.git/2022/10/20/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B-05%EF%BC%9A%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</id>
    <published>2022-10-20T00:22:48.000Z</published>
    <updated>2023-01-29T17:08:43.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C语言中的输入与输出"><a href="#C语言中的输入与输出" class="headerlink" title="C语言中的输入与输出"></a>C语言中的输入与输出</h2><p>在第二节我们曾经介绍<code>#include&lt;stdio.h&gt;</code>的含义是包含一个标准输入输出的头文件，随即在第三节我们又学习了printf()语句。printf()是一个最为常见的输出语句，那么除此之外，C语言中还有那些输入输出语句呢？<br>C语言中有三对输入输出语句，由于格式相似，我们分三对介绍。</p><h2 id="最常用的输入输出语句：scanf-与printf"><a href="#最常用的输入输出语句：scanf-与printf" class="headerlink" title="最常用的输入输出语句：scanf()与printf()"></a>最常用的输入输出语句：scanf()与printf()</h2><p>作为相对应的输入输出字符，scanf()与printf()在形式上都是由一个英文单词加上format的缩写f构成，其使用起来也遵循类似的规则，使用起来都需要在括号内加入双引号来限定内容，将双引号内的内容原样输入或输出。正如\n这类转义字符具有特殊作用一样，在scanf()和printf()中还存在着一个特殊的，具有特殊作用而不被原样输出输出的符号，称之为格式字符。</p><h3 id="scanf-与printf-语句中的格式字符"><a href="#scanf-与printf-语句中的格式字符" class="headerlink" title="scanf()与printf()语句中的格式字符"></a>scanf()与printf()语句中的格式字符</h3><p>在scanf()和printf()中，形如%d这类%加字母的就被称之为格式字符。<br>格式字符，顾名思义，是来限定输出内容格式的，为了便于学习，我们在此只陈列一些最为常用的格式字符：</p><table><thead><tr><th align="center">格式字符</th><th align="center">格式说明</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">带符号的十进制整数</td></tr><tr><td align="center">%u</td><td align="center">无符号的十进制整数</td></tr><tr><td align="center">%c</td><td align="center">一个字符</td></tr><tr><td align="center">%s</td><td align="center">一个字符串</td></tr><tr><td align="center">%f</td><td align="center">浮点数，即小数</td></tr></tbody></table><p>当我们对输入输出的格式进行限定后， 此时我们会发现少了些什么：我们明确了输出输出的格式，却没有明确我们要格式化的对象，接下来我们就将要学习如何在输入输出语句中确定格式化的对象。</p><h3 id="用逗号间隔开来的补充说明：变量的首次运用"><a href="#用逗号间隔开来的补充说明：变量的首次运用" class="headerlink" title="用逗号间隔开来的补充说明：变量的首次运用"></a>用逗号间隔开来的补充说明：变量的首次运用</h3><p>类似于英语中的同位语，我们可以在括号内、引号后的位置使用逗号，从而确定我们要输入输出的对象。这个对象，可以是变量，也可以是含有变量的表达式。下面我们看一个例子来学习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> example_1;</span><br><span class="line">    <span class="type">float</span> example_2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %f&quot;</span>, &amp;example_1, &amp;example_2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %f&quot;</span>, example_1, example_2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1.png"></p><p>通过这个例子，我们可以总结出3点规律：</p><ol><li>引号内内容应当原样输入输出，包括空格和其他字符；</li><li>引用变量时的格式字符应该与声明时的对应，不一致的格式可能会造成数据丢失或者报错；</li><li>输入语句scanf()中引用变量时要用上&amp;，&amp;的名称是取地址符，整个scanf()语句的意思就是将输入的值赋给变量所分配的地址，关于地址的更多详情，我们会在指针一节中提及，这里我们可以看做将输入的值赋给&amp;后的变量；</li></ol><h3 id="对格式字符的附加修饰"><a href="#对格式字符的附加修饰" class="headerlink" title="对格式字符的附加修饰"></a>对格式字符的附加修饰</h3><p>在实际运用中，我们可能还要对格式进行进一步要求，这里就引入了对格式字符的附加修饰字符，由于输出输出语句中修饰字符存在细微差别，我们这里分别介绍。<br>在输入语句中我们以整型%d为例，*%d表示数据在输入后不进行赋值，%nd表示将输入数据的前n位赋值，%hd表示输入短整型，%ld表示输入长整型。<br>在输出语句中我们以浮点型%f为例，%lf表示输出双精度double型，%mf表示输出数据最小宽度为m格，%mf表示输出数据最小宽度为m格且少的位置用0补齐，%.nf表示输出数据小数点后有n位，%-f表示输出数据想左靠。</p><h2 id="适用于字符的输入输出语句：getchar-与putchar"><a href="#适用于字符的输入输出语句：getchar-与putchar" class="headerlink" title="适用于字符的输入输出语句：getchar()与putchar()"></a>适用于字符的输入输出语句：getchar()与putchar()</h2><p>对于字符型乃至接下来所说的字符串型，它们也同样遵循上文我们所总结出来的第二条规律，即格式的相统一。<br>而不同它们和第一类相比，也有着许多不同之处，这里我们以输入输出的顺序依次介绍。</p><h3 id="关于getchar"><a href="#关于getchar" class="headerlink" title="关于getchar()"></a>关于getchar()</h3><p>作为简单的输入语句，getchar()在使用时有一下几点需要注意：</p><ol><li>getchar()会接收键盘输入的第一个字符，无论它是符号、数字、字母甚至是空格；</li><li>getchar()的赋值可以直接用等号，例如：<code>name = getchar</code>；</li></ol><h3 id="关于putchar"><a href="#关于putchar" class="headerlink" title="关于putchar()"></a>关于putchar()</h3><p>作为简单的输出语句，putchar()在使用时有一下几点需要注意：</p><ol><li>在对字符字符进行原样输出是括号内用的是单引号而非双引号；</li><li>括号内引号中可以是转义字符，例如<code>\101</code>就会输出<code>A</code>；</li><li>可以直接在括号内输入变量名来输出它所对应的字符；</li></ol><h2 id="适用于字符串的输入输出语句：gets-与puts"><a href="#适用于字符串的输入输出语句：gets-与puts" class="headerlink" title="适用于字符串的输入输出语句：gets()与puts()"></a>适用于字符串的输入输出语句：gets()与puts()</h2><p>字符串的输入输出可能会涉及指针等后续内容，本节内容我们将在指针后介绍。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>作为最常用的输入输出语句scanf()与printf()，学好它们以及配套的格式字符、修饰字符便足以应对大多数环境。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C语言中的输入与输出&quot;&gt;&lt;a href=&quot;#C语言中的输入与输出&quot; class=&quot;headerlink&quot; title=&quot;C语言中的输入与输出&quot;&gt;&lt;/a&gt;C语言中的输入与输出&lt;/h2&gt;&lt;p&gt;在第二节我们曾经介绍&lt;code&gt;#include&amp;lt;stdio.h&amp;gt</summary>
      
    
    
    
    <category term="C语言教程" scheme="https://gitee.com/cloudstill/cloudstill.git/categories/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="教程" scheme="https://gitee.com/cloudstill/cloudstill.git/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
