[{"title":"ADarkRoom","url":"/2023/02/10/ADarkRoom/","content":"前言在2020上网课时期，我在互联网上找到了一款名为小黑屋的页游，简洁的界面和言简意赅的剧情一下子吸引了我，但游戏内容却在进入太空后戛然而止。基于此，我们决定开启ADarkRoom计划，本计划仅作为学习交流所用，如有侵权请联系删除。\n原版你可以点击这里或者从html导航栏中找到ADarkRoom。\n项目进程\n暂无\n\n","categories":["游戏"],"tags":["游戏"]},{"title":"C语言教程_02：一个简单的C程序","url":"/2022/10/06/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B-02%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84C%E7%A8%8B%E5%BA%8F/","content":"一个简单的C程序在接触C语言之前，大家或多或少会对C语言产生敬畏之心，认为它是一门很高深的语言，实则不然，且看代码：\n#include &lt;stdio.h&gt;int main()&#123;    /* 我的第一个 C 程序 */     printf(&quot;Hello, World! \\n&quot;);    return 0;&#125;// 注：以//打头的某一行或者用/**/括起来的数行在程序中统称为注释，不会被编译器所编译// 一个好的注释对于程序而言是很重要的，它不仅可以让别人看懂你的代码，也可以便于自我的纠察\n\n运行结果\n代码分析观察这个程序代码，大家会发现它非常的简单，然而，作为一个程序它却相当完整。我们可以简单将其分为三个部分，一是由#include打头的部分，二是int main()，三则是&#123;&#125;内的内容，这三个部分的存在，也就构成了一个完整的C程序接下来将对这三个部分进行逐一分析。\n#include &lt;stdio.h&gt;\n\n#号所起的是一个标识的作用，是一个规范，可以看作无实际意义。include在英文中有包含的意思。stdio.h可以分为四个部分解读，std是standard的缩写，standard意为标准；i是input的缩写，input意为输入；o是output的缩写，output意为输出；h是head的缩写，head意为头，而.h顾名思义则是头文件的后缀。将这样一段代码逐字分析后拼接在一起，清晰指向了一个信息“这个程序可能包含一个标准输入输出的头文件”。\nint main()\n\nint被称为关键字，其作用是指定义main函数返回值的类型为int型，int型即整型，暂且可以将其等价于整数。在程序中这一部分称为函数头。main函数作为C程序中至关重要的部分，在每一个C程序中都会有一个main函数，作为一个程序的入口部分，也就是说程序都是从main函数头开始执行，然后进入到main函数中，执行其中语句的。()内的内容是我们可以填充的，初学C程序，可以暂且不管。\n&#123;    printf(&quot;......&quot;);    ......&#125;\n\n{}可以起到一个囊括的作用，其内部作为一个整体，称之为函数体。printf()作为其中的一部分，我们将其成为执行语句，其中print的意思为打印或者输出，而f是format的缩写，意为格式化，故printf()的意思就是格式化输出括号内的内容。这里我们提到一个词输出，正是我们之前所提到了的“标准输入输出”中的“输出”。\nreturn 0;\n\nreturn 0并不属于执行语句，我们将其称之为return语句。return的作用是向程序返回一个值，在这里就是0，而0又恰好是一个整数，符合int类型。值得一提的是，C程序是严格区分中英文的，一切语句都要用英文进行书写，且在函数体内部的内容，执行语句和return语句末尾，都要加上；表示一条语句的结束，这也就意味着，C程序在编译时会跳过空格以及空行（和注释）直接跳到下一条语句。\n总结对这样一个代码进行逐字分析后，相信大家对于C程序的概念有了一个具体的认知，并且，对于C语言不再过于恐惧。\n","categories":["C语言教程"],"tags":["C语言","教程"]},{"title":"C语言教程_03：printf()与转义字符","url":"/2022/10/19/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B-03%EF%BC%9Aprintf%E4%B8%8E%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/","content":"关于printf()在上一节中我们以一个程序为例展开我们C语言学习的第一步，这节我们将再次以它为例：\n#include &lt;stdio.h&gt;int main()&#123;    /* 我的第一个 C 程序 */    printf(&quot;Hello, World! \\n&quot;);    return 0;&#125;\n\n在上一节我们介绍C程序结构时，我们并没有探讨printf()后面跟的()以及其中的内容。以上述程序为例子：\nprintf(&quot;Hello, World! \\n&quot;);\n\n括号所构成的一个整体可以看作printf()的一个宾语，相当于语言学中的动宾结构。而括号内的内容我们可以看到是由一对引号包裹在内的，并且当我们实际运行该程序时，这个引号并没有显示出来，而引号内的其他内容（除了\\n）都被原样打印了出来。由此我们可以知道printf()在打印时，会原样地打印出括号内引号所包裹的大部分内容。那么，为什么\\n不会被打印呢？\n转义字符转义字符（Escape character），所有的ASCII码都可以用“\\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加”&quot;来表示常见的那些不能显示的ASCII字符，如\\0,\\t,\\n等，就称为转义字符，因为后面的字符，都不是它本来的ASCII字符意思了。关于ASCII码大家可以自行或点击此处了解更多。\n关于\\n在介绍printf()时，我们曾疑惑于为何\\n不会被打印出来，而在刚刚我们了解到了转义字符，明白了转义字符的意义，同时也知道了转义字符不会被显示出来的机制。那么\\n所代表的是什么意思呢？如果你尝试过在我们演示的代码里加入多行printf()而不加\\n，你会发现这些内容前后连接到了一起；而如果你加入了\\n，你会发现它们一行一行分布。由此我们很容易才想到\\n所起到的是换行的作用。那么除了\\n，还有哪些转义字符呢？\n转义字符表\n\n\n转义字符\n意义\nASCII码值（十进制）\n\n\n\n\\a\n响铃(BEL)\n007\n\n\n\\b\n退格(BS) ，将当前位置移到前一列\n008\n\n\n\\f\n换页(FF)，将当前位置移到下页开头\n012\n\n\n\\n\n换行(LF) ，将当前位置移到下一行开头\n010\n\n\n\\r\n回车(CR) ，将当前位置移到本行开头\n013\n\n\n\\t\n水平制表(HT)\n009\n\n\n\\v\n垂直制表(VT)\n011\n\n\n\\‘\n单引号\n039\n\n\n\\“\n双引号\n034\n\n\n\\\\\n反斜杠\n092\n\n\n结语转义字符是C语言中为数不多需要记忆的东西，但我们并不倡导死记硬背，你应当去尝试上述每一个转义字符，在实践中感受它们的作用。\n","categories":["C语言教程"],"tags":["C语言","教程"]},{"title":"C语言教程_05：输入与输出","url":"/2022/10/20/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B-05%EF%BC%9A%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/","content":"C语言中的输入与输出在第二节我们曾经介绍#include&lt;stdio.h&gt;的含义是包含一个标准输入输出的头文件，随即在第三节我们又学习了printf()语句。printf()是一个最为常见的输出语句，那么除此之外，C语言中还有那些输入输出语句呢？C语言中有三对输入输出语句，由于格式相似，我们分三对介绍。\n最常用的输入输出语句：scanf()与printf()作为相对应的输入输出字符，scanf()与printf()在形式上都是由一个英文单词加上format的缩写f构成，其使用起来也遵循类似的规则，使用起来都需要在括号内加入双引号来限定内容，将双引号内的内容原样输入或输出。正如\\n这类转义字符具有特殊作用一样，在scanf()和printf()中还存在着一个特殊的，具有特殊作用而不被原样输出输出的符号，称之为格式字符。\nscanf()与printf()语句中的格式字符在scanf()和printf()中，形如%d这类%加字母的就被称之为格式字符。格式字符，顾名思义，是来限定输出内容格式的，为了便于学习，我们在此只陈列一些最为常用的格式字符：\n\n\n\n格式字符\n格式说明\n\n\n\n%d\n带符号的十进制整数\n\n\n%u\n无符号的十进制整数\n\n\n%c\n一个字符\n\n\n%s\n一个字符串\n\n\n%f\n浮点数，即小数\n\n\n当我们对输入输出的格式进行限定后， 此时我们会发现少了些什么：我们明确了输出输出的格式，却没有明确我们要格式化的对象，接下来我们就将要学习如何在输入输出语句中确定格式化的对象。\n用逗号间隔开来的补充说明：变量的首次运用类似于英语中的同位语，我们可以在括号内、引号后的位置使用逗号，从而确定我们要输入输出的对象。这个对象，可以是变量，也可以是含有变量的表达式。下面我们看一个例子来学习：\n#include&lt;stdio.h&gt;int main()&#123;    int example_1;    float example_2;    scanf(&quot;%d %f&quot;, &amp;example_1, &amp;example_2);    printf(&quot;%d %f&quot;, example_1, example_2);    return 0;&#125;\n\n\n通过这个例子，我们可以总结出3点规律：\n\n引号内内容应当原样输入输出，包括空格和其他字符；\n引用变量时的格式字符应该与声明时的对应，不一致的格式可能会造成数据丢失或者报错；\n输入语句scanf()中引用变量时要用上&amp;，&amp;的名称是取地址符，整个scanf()语句的意思就是将输入的值赋给变量所分配的地址，关于地址的更多详情，我们会在指针一节中提及，这里我们可以看做将输入的值赋给&amp;后的变量；\n\n对格式字符的附加修饰在实际运用中，我们可能还要对格式进行进一步要求，这里就引入了对格式字符的附加修饰字符，由于输出输出语句中修饰字符存在细微差别，我们这里分别介绍。在输入语句中我们以整型%d为例，*%d表示数据在输入后不进行赋值，%nd表示将输入数据的前n位赋值，%hd表示输入短整型，%ld表示输入长整型。在输出语句中我们以浮点型%f为例，%lf表示输出双精度double型，%mf表示输出数据最小宽度为m格，%mf表示输出数据最小宽度为m格且少的位置用0补齐，%.nf表示输出数据小数点后有n位，%-f表示输出数据想左靠。\n适用于字符的输入输出语句：getchar()与putchar()对于字符型乃至接下来所说的字符串型，它们也同样遵循上文我们所总结出来的第二条规律，即格式的相统一。而不同它们和第一类相比，也有着许多不同之处，这里我们以输入输出的顺序依次介绍。\n关于getchar()作为简单的输入语句，getchar()在使用时有一下几点需要注意：\n\ngetchar()会接收键盘输入的第一个字符，无论它是符号、数字、字母甚至是空格；\ngetchar()的赋值可以直接用等号，例如：name = getchar；\n\n关于putchar()作为简单的输出语句，putchar()在使用时有一下几点需要注意：\n\n在对字符字符进行原样输出是括号内用的是单引号而非双引号；\n括号内引号中可以是转义字符，例如\\101就会输出A；\n可以直接在括号内输入变量名来输出它所对应的字符；\n\n适用于字符串的输入输出语句：gets()与puts()字符串的输入输出可能会涉及指针等后续内容，本节内容我们将在指针后介绍。\n结语作为最常用的输入输出语句scanf()与printf()，学好它们以及配套的格式字符、修饰字符便足以应对大多数环境。\n","categories":["C语言教程"],"tags":["C语言","教程"]},{"title":"C语言教程_01：编译环境","url":"/2022/10/06/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B-01%EF%BC%9A%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/","content":"前言学习C语言，一个好用的ide必不可少。目前各大高校大多采用的是VC++6.0作为编译环境，众所周知，这款ide由微软于1993年推出，其年龄相较于我而言也要大上10岁。计算机学科本身就是一门走在时代前沿需要创新的学科，一款落后于时代的ide，即使它十分经典，在笔者看来，也是可以被优化的。\nVisual Studio 2022本教程推荐Visual Studio 2022作为编译环境，其原因有以下几点，一是由于它够新，对于新手学习C语言而言其相对比较友好，一旦体验过&#96;Visual Studio 2022和其他ide，如上文所提及的VC++6.0，你就明显感觉到它的好用；二则是你可以在Visual Studio官网免费下载Visual Studio Community 2022。你可以通过搜索引擎搜索Visual Studio 2022到官网下载，你也可以点击此处进行下载。\nVisual Studio 2022使用教学关于Visual Studio 2022的使用教学，受限于文字形式，无法具体地和大家展开，这里推荐B站的一位up主，同时也是我C语言的启蒙老师：Micro_Frank你也可以在B站搜索由他创作的 vs2022(Visual Studio 2022)权威指南&amp;&amp;C语言&amp;&amp;软件工程开发的方向&amp;&amp;技巧要领你可以点击此处直接观看教程\nVisual Studio 2022无法下载目前从官网下载Visual Studio 2022时可能会存在下载进度静止不动的问题，这里提供一种解决方案\nDev-C++此外你也可以选用Dev-C++作为你的编译环境，Dev-C++作为一款较为简单的ide，是许多比赛项目的指定的ide之一。出于此，本教程选用Dev作为编译环境。同样你可以点击此处下载。\nCLionCLion作为JetBrains开发的一款ide，我们耳熟能详的PyCharm和IntelliJ同时也出自其旗下，官方正版的CLion并不免费，你可以点击此处下载。\nVisual Studio CodeVS Code作为微软公司开发的另一款ide，经调试可以支持多种语言，同时具有轻量化的优点，你可以点击此处下载。\n","categories":["C语言教程"],"tags":["C语言","教程"]},{"title":"C语言教程_04：变量与常量","url":"/2022/10/19/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B-04%EF%BC%9A%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/","content":"生活中变量与常量生活中会遇到很多量：一件商品的价格、每个月的生活费……这些量可以被分为两类：常量和变量。\n\n什么是常量？顾名思义，一个常数、一个不变化的量，我们最熟悉的常量就是PAI、自然对数e。\n什么是变量？同样是顾名思义，一个变化的量就是变量。\n常量大家都可以理解，可变量未必理解得容易，这里我们以《植物大战僵尸》为例。在上图中，我们拥有100阳光，而一株豌豆的阳光价格为100。对于阳光，我们所持有的阳光数量会随着我们对阳光的获取和消耗变化，这就是变量。与此同时，豌豆的价格却始终是100，这就是一个常量。\n\nC语言中的变量与常量生活中的变量和常量我们已经了解，那么C语言中的呢？在C语言中，对应一个量而言，我们可以对其进行声明和定义两类操作。任何一个量，它的初始化，也就是声明都是必不可少的。这也就意味着，如果你没有对其进行定义，系统会随机对其定义一个值。一个不变化的变量可以发挥常量的作用，可一个常量却不能随意变化，为了便于学习，我们在本节只介绍变量。\nC语言中变量的声明在最开始我们介绍C程序时，我们说过一句话“int被称为关键字，其作用是指定义main函数返回值的类型为int型，int型即整型，暂且可以将其等价于整数”，当时你可能对这句话不太理解，没关系当我们介绍完变量的声明后，你就会明白。首先我们必须要理解为什么要声明变量，在C语言中会有很多字符，如果我们不声明一个字符，我们就无法判定这个字符是一个变量名，更别说它的类型了。敏锐的读者会注意到上述文字中的两个关键点，变量名和变量的类型\n变量名的命名规范与艺术如同人有名字一样，每一个变量也有着它的名字，作为程序员的我们，就像变量的父母一样，拥有着给它们取名的权利。同样，正如现实生活中取名字有一定规范一样，我们给变量取名也要遵循一定的规则，具体规则如下：\n\n变量名的开头必须为字母或下划线，大小写均可；\n变量名中不可以有符号，但是可以有下划线，也就是“_”；\n变量名中允许使用任意的大小写字母以及数字；\n变量名不能与关键字同名；\n\n如同人有名字一样，变量名也有“好听”与“不好听”的区别。只不过不同于人对名字的要求，变量名遵循一个简单的原则，即“顾名思义”。一个好的变量名应当是简洁明了的，用abcd来表示四个变量这样简单的命名方式固然方便快捷，可在一个有着很多变量的程序中轻易就会被混淆，加之很少有人会有勤写注释的习惯，一个自己写的程序过上几天也会看得一头雾水。而用number_1，number_2来表示两个变量这样的命名方式呢？这样的命名方式确实做到了顾名思义，也值得我们倡导，可在实际编写中，number不如简化成num，num_1,num_2这样的命名方式会更加简明。一个好的C程序并不是说没有bug就可以了，变量名的艺术也值得我们深入研究。\n注：实际操作中变量名的取名要视环境而定，比如那种写一次就行了的比赛题目，随便取个abcd完全可以。\n变量的类型在之前我们就说过int作为关键字所声明的是int型，即整型，可视为整数。有短整型就有长整型，有整数就有小数，有整数型就有小数型。只不过在C语言中小数并不称为小数，小数型也不叫小数型，它们分别称为浮点数和浮点型，除此之外还有一种类型为字符型。整数型和字符型可以并为整数类型，它们遵循以下表格中的规律：\n\n\n\n类型\n存储大小\n值范围\n\n\n\nchar\n1 字节\n-128 到 127 或 0 到 255\n\n\nunsigned char\n1 字节\n0 到 255\n\n\nsigned char\n1 字节\n-128 到 127\n\n\nint\n2 或 4 字节\n-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647\n\n\nunsigned int\n2 或 4 字节\n0 到 65,535 或 0 到 4,294,967,295\n\n\nshort\n2 字节\n0 到 65,535\n\n\nunsigned short\n2 字节\n1.2E-38 到 3.4E+38\n\n\nlong\n4 字节\n-2,147,483,648 到 2,147,483,647\n\n\nunsigned long\n4 字节\n0 到 4,294,967,295\n\n\n注：各种类型的存储大小与系统位数有关，但目前通用的以64位为主。\n而与整数类型相对的浮点类型则遵循以下表格：\n\n\n\n类型\n存储大小\n值范围\n精度\n\n\n\nfloat\n4 字节\n1.2E-38 到 3.4E+38\n6 位有效位\n\n\ndouble\n8 字节\n2.3E-308 到 1.7E+308\n15 位有效位\n\n\nlong double\n16 字节\n3.4E-4932 到 1.1E+4932\n19 位有效位\n\n\n对于这样的表格记忆是很困难的，我们只需要记住一些基础的就可以应对大多数情况了。我们可以先记住char为字符型，int为短整型，如果数据很大就换成long。如果数据为小数就用单精度浮点型float声明，对精度要求很高或是数据过大就用双精度型double。\nC语言中变量的定义当我们声明一个变量后，我们需要对它进行赋值，这个过程就称之为定义，变量的定义可以以多个方式进行，这里我们以int为例，有以下情况：1.声明时定义\nint example_1 = 1;\n\n在声明的同时定义，把1的值赋给变量example_1.2.声明后定义\nint example_2;emaxple_2 = 2;\n\n在声明后定义，将2的值赋给变量example_2.变量的定义相对自由，&#x3D;后面可以跟其他变量和表达式（如 加+ 减- 乘* 除/ 取余% 所连接的式子）。值得注意的是，在上面我介绍=时我所用的是赋值而非相等，这是一个比较严谨的称呼，在C语言中判断是否相等时我们需要用的是==；另一个值得注意的点是，当=左右数据类型不相等时，会转化成左边变量的数据类型，这也就意味着，将浮点型赋值给整数型时会损失小数点后的内容，将高精度浮点型赋值给低精度浮点型时会损失所相差的那一部分精度。\n结语Frank曾经说过，变量是玩会的而不是学会的，这也就是为什么我要以《植物大战僵尸》为例的原因。单纯的介绍变量并不能让人完全理解它，在下一节我们将学习C语言中的输入与输出（我们已经学过的printf()就是一个输出语句），届时我们就能领会到变量的神奇之处。\n","categories":["C语言教程"],"tags":["C语言","教程"]},{"title":"C语言教程_06：判断语句二三事","url":"/2022/12/12/C%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B-06%EF%BC%9A%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E4%BA%8C%E4%B8%89%E4%BA%8B/","content":"不为谁而作的歌当我写下这段文字时。距离上一次更新本教程已经过去了快两个月。两个月的时间，我的心态也发生了很大的变化，再一次更新，更多的不再是为了谁谁。\nif语句if相信大家都不陌生，在英文中它有着“如果”的意思，它引导的条件状语从句可以翻译为“如果……就……”，而在C语言中，它也有着相同的用法，且看下面的例子：\nif(......)&#123;  ......&#125;\n\n套用英语中的逻辑来理解这个例子，把它翻译成中文就是“如果小括号里面的内容成立，那么花括号里面的内容也成立”。小括号里面可以填什么呢？数字，变量，表达式，关系式都可以。对于数字和变量，在计算机中，无论它们的值是多少，都只有0和非0的区别，非0又可以理解为1。我们都知道在计算机中0表示假，1表示真。即小括号里的数字和变量如果为0，语句不成立，为1（非0）则成立。对于表达式，程序会先将其进行运算之后，再对其数值进行如对数字和变量相同的操作。对于关系式，它们同样遵循01原则，当关系式成立时它们相当于1，当关系式不成立时它们相当于0。说完小括号我们再来说说花括号，花括号里填写的是函数语句，函数语句的成立意味着执行，这也就是说，一旦小括号里的值为1，那么就会执行花括号里的内容。\n","categories":["C语言教程"],"tags":["C语言","教程"]},{"title":"数据结构_01：概论","url":"/2022/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-01%EF%BC%9A%E6%A6%82%E8%AE%BA/","content":"什么是数据结构一般来说，用计算机解决一个具体问题时，大致需要经过下列几个步骤：首先要从具体问题抽象出一个适当的数学模型，然后设计一个解此数学模型的算法，最后编出程序，进行测试、调整直至得到最终解答。寻求数学模型的实质是分析问题，从中提取操作的对象，并找出这些操作对象之间含有的关系，然后用数学的语言加以描述。例如，求解梁架结构中应力的数学模型为线性方程组；预报人口增长情况的数学模型为微分方程。然而，更多的非数值计算问题无法用数学方程加以描述。在生活中随处可见这样的例子，如图书馆数目检索系统自动化问题，计算机和人对弈问题，多叉路口交通灯的管理问题等等。在这三个例子中，我们描述问题的数学模型是称为“表”“树“和”图“的数据结构而非一个简单的数学方程。因此，简单来说，数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等的学科。\n目录\n顺序表\n链表\n特殊链表\n栈\nPost not found: 数据结构-06：队列 队列（未更新）\nPost not found: 数据结构-07：线性表实战 线性表实战（未更新）\nPost not found: 数据结构-08：二叉树 二叉树（未更新）\nPost not found: 数据结构-09：高级树 高级树（未更新）\nPost not found: 数据结构-10：其他树 其他树（未更新）\nPost not found: 数据结构-11：树实战 树实战（未更新）\nPost not found: 数据结构-12：散列表 散列表（未更新）\nPost not found: 数据结构-13：图 图（未更新）\nPost not found: 数据结构-14：图应用 图应用（未更新）\nPost not found: 数据结构-13：排序算法 排序算法（未更新）\n\n","categories":["数据结构"],"tags":["C语言","教程","数据结构"]},{"title":"备战蓝桥杯_算法_01：递归","url":"/2022/12/16/%E5%A4%87%E6%88%98%E8%93%9D%E6%A1%A5%E6%9D%AF-%E7%AE%97%E6%B3%95-01%EF%BC%9A%E9%80%92%E5%BD%92/","content":"前言已经数不清这是开的第几个坑了，蓝桥杯虽然含金量不高，但是对于我这样的初学者而言确是一次很好的历练机会，为了记录我备赛的过程，特此开了这个坑。声明：本系列源于CSDN博主Androids_lost_Sheep的博文《蓝桥杯知识点汇总：基础知识和常用算法》，博主所采用的编程语言为Java，本系列将采用C语言作为编程语言。\n什么是递归递归的含义很好理解，就是一个函数调用自身，难就难在如何确定一个题目的递归式，这就需要多刷题了。一个完整的递归函数包含两个部分:\n\n递归式\n递归出口\n\n以斐波那契数列为例：\nint f(int n)&#123;\tif(n == 1 || n == 2)    return 1; // 递归出口\treturn f(n-1) + f(n-2); // 递归式&#125;\n\n递归式用来递归计算我们想要得到的值， 递归出口用来结束递归。如果没有递归出口，那么就会一直递归下去，就造成了死循环。那么什么题会用到递归呢？子问题和原问题求解方式完全相同的，可以用递归。\n一个递归的例子题目：计算n阶行列式\n给定一个N×N的矩阵A，求|A|。输入格式：第一行一个正整数N。 接下来N行，每行N个整数，第i行第j个数字表示A[i][j]。输出格式：一行，输出|A|。  \n\n思路：寻找递归在通过递归解决问题时，我们往往只需要关注n到n-1步的变化规律，然后将其不断重复到跳出条件即可。对于本题而言，计算行列式的一个通法是拉普拉斯展开，故我们要考虑n阶行列式到n-1阶行列式的变化过程。\n代码示例#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define MAX 100int DET(int num_1[MAX][MAX], int n);int Minor(int num_1[MAX][MAX], int i, int n);int main() &#123;\tint num_1[MAX][MAX];\tint i,j,n;\tscanf(&quot;%d&quot;,&amp;n);\tfor(i=0;i&lt;n;i++)\t&#123;\t\tfor(j=0;j&lt;n;j++)\t\t&#123;\t\t\tscanf(&quot;%d&quot;,&amp;num_1[i][j]);\t\t&#125;\t&#125;\tprintf(&quot;%d&quot;,DET(num_1,n));\treturn 0;&#125;int DET(int num_1[MAX][MAX],int n)&#123;\tint i,M,sum=0;\tif(n==1)\t&#123;\t\treturn num_1[0][0];\t&#125;\telse if(n&gt;1)\t&#123;\t\tfor(i=0;i&lt;n;i++)\t\t&#123;\t\t\tM=Minor(num_1,i,n);\t\t\tsum=sum+pow(-1,i+2)*num_1[0][i]*M;\t\t&#125;\t&#125;\treturn sum;&#125;int Minor(int num_1[MAX][MAX],int i,int n)&#123;\tint j,k,result;\tint num_2[MAX][MAX];\tfor(j=0;j&lt;n-1;j++)\t&#123;\t\tfor(k=0;k&lt;n-1;k++)\t\t&#123;\t\t\tif(k&lt;i)\t\t\t&#123;\t\t\t\tnum_2[j][k]=num_1[j+1][k];\t\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\telse if(k&gt;=i)\t\t\t&#123;\t\t\t\tnum_2[j][k]=num_1[j+1][k+1];\t\t\t&#125;\t\t&#125;\t&#125;\treturn DET(num_2,n-1);&#125;\n\n递归练习递归实现指数型枚举题目\n从 1∼n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。输入格式输入一个整数 n。输出格式每行输出一种方案。同一行内的数必须升序排列，相邻两个数用恰好 1 个空格隔开。对于没有选任何数的方案，输出空行。本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。数据范围1≤n≤15输入样例：3输出样例：322 311 31 21 2 3  \n\n思路","categories":["蓝桥杯"],"tags":["C语言","教程","练习"]},{"title":"LeetCode_1_两数之和","url":"/2022/10/11/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"题目\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。示例 1：输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。示例 2：输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]示例 3：输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1] 提示：2 &lt;&#x3D; nums.length &lt;&#x3D; 104-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109-109 &lt;&#x3D; target &lt;&#x3D; 109只会存在一个有效答案进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n\n思路太难了，还不会。\n程序实例有人相爱，有人夜里开车看海，有人leetcode第一题都做不出来。\n","categories":["LeetCode"],"tags":["C语言","练习"]},{"title":"数据结构_02：顺序表","url":"/2023/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-02%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8/","content":"数组和表的区别在开启本教程学习之前，相信大家已经有了一定语言基础，对于数组，大家一定十分熟悉。我们在使用数组时，或多或少会遇到以下几个问题：\n\n必须在一开始就声明数组的长度；\n无法随时随用地对数组进行扩容，这就导致了一开始声明的数组的长度必须足够大；\n可能会存在未使用的数组，这对内存是一种浪费。\n\n而表，就是一种可以解决这些问题的数据结构。关于数组和表，更多的区别需要可能会涉及一些更加深层的知识，这里不做赘述，欢迎自己探知。\n顺序表按照惯例，我们一般需要对顺序表进行一定的介绍：顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。为了方便理解，我们可以简单地认为他是一种可以动态变化的连续存储的数组。\n定义结构体顺序表的实现有很多方式，其中，我们采取结构体的方式。首先我们需要定义一个结构体：\nstruct list&#123;  int* array;  int capacity;  int size;&#125;;\n\n在这段代码中，我们定义了一个叫list的结构体，它包含了三个成员，整型指针变量array，整型变量capacity和整型变量size。和它们的名字一样，array表示顺序表所占的内存空间，capacity表示顺序表的理论最大容量，size表示顺序表中已经填满的容量，即实际长度。\n初始化当我们定义完结构体后，我们还没有真正创建一个顺序表，即便我们在main函数中创建了一个结构体变量，它也不能真正算得上一个顺序表。一个顺序表的实现必须要对其进行初始化，为了便于多次使用，我们采取自定义一个初始化函数的方式实现。在此之前，为了便于后续操作，我们可以使用typedef函数将结构体指针struct list*重命名为arraylist，即：\ntypedef struct list* arraylist;\n\n此后涉及struct list*的内容我们一律用arraylist代替，请根据需求自行代换。根据我们此前定义的结构体的三个成员内存array，容量capacity，长度size，我们可以设想到初始化需要进行的操作。我们都知道计算机在存储数据时需要用到内存空间，所以我们在初始化时，需要使用malloc()函数申请一块内存空间，使用此函数前我们需要引入新的头文件&lt;stdlib.h&gt;，即：\n#include&lt;stdlib.h&gt;\n\n接着，我们需要用变量表示顺序表初始的最大容量和实际长度。综上，初始化一个顺序表需要实现以下三个功能：\n\n向计算机申请一块内存空间；\n表示顺序表初始最大容量；\n表示顺序表初始实际长度，即0；\n\n实现这三个功能并不难，即：\nvoid setuplist(arraylist list)&#123;  list-&gt;capacity=1;//此处初始化顺序表容量为1，实际可更改  list-&gt;array=malloc(sizeof(int)*list-&gt;capacity);  list-&gt;size=0;&#125;\n\n观察上述代码块，有几点值得我们注意：\n\n在学习函数章节时，我们已经知道了函数传值和传地址的区别，此处由于我们需要对顺序表地址进行操作，故需要用到结构体指针；\n表示结构体指针的成员需要用到-&gt;符号，或者也可以用(*指针名).成员名表示；\nsizeof()函数会根据括号内的数据类型换算成对应的内存大小；\n\n当我们深入了解malloc()函数后，我们会知道有时malloc()函数也会申请内存失败，此时它会返回NULL，同时申请失败也就意味着初始化失败，我们可以采取一种方式来表示初始化的成功与否。我们可以用布尔型返回true和false来表示初始化的结果，但是我们都知道true&#x3D;1，false&#x3D;0，又因为C语言中可能存在没有布尔型的情况，此处我们仅仅展示一个在部分C语言标准下存在的代码块，后续涉及判断内容我们一律采用int型，代码块即：\n...#include&lt;stdbool.h&gt;..._Bool test_1=true;bool test_2=false;...\n\n对于增加判断申请内存失败与否的初始化函数，即：\nint setuplist(arraylist list)&#123;  list-&gt;capacity=1;  list-&gt;array=malloc(sizeof(int)*list-&gt;capacity);  if(list-&gt;array==NULL)    return 0;  list-&gt;size=0;  return 1;&#125;\n\n至此，我们已经实现了顺序表的初始化功能。\n扩容当我们初始化一个顺序表后，有时我们会面临最大容量不足的情况，当然我们一开始初始化的可以很容易的保证最大容量足够第一次使用，可是当我们后续使用时，有时要对其进行扩容。在C语言中本身提供了realloc()函数重新申请一块内存，和malloc()一样，它也是包含于&lt;stdlib.h&gt;头文件中的，扩容的操作极其简单，即：\nint extendlist(arraylist list)&#123;  int newcapacity=list-&gt;capacity*2;//内存扩展两倍  int* newarray=realloc(list-&gt;array, sizeof(int)*newcapacity);  if(newarray==NULL)    return 0;  list-&gt;array=newarray;  list-&gt;capacity=newcapacity;  return 1;&#125;\n\n插入一个顺序表被创建出来后，其中并没有元素，这时我们可以对其进行插入。和插入数组一样，我们顺序表的插入也需要三个要素：\n\n被插入的顺序表；\n插入的数字；\n插入的位置。\n\n基于此，我们很容易就可以设计出一个插入顺序表的函数，在我们正式开始进行写代码前，我们可以很容易的预见一些插入过程中可能会发生的问题：\n\n插入的位置在可插入的位置之外；\n顺序表容积已满，需要扩容；\n如何选择插入的方法。\n\n关于第一个问题，我们一般认为顺序表从的位置从1开始，那么当我们插入的位置小于1或很大时，这个插入是不可取的；关于第二个问题，我们只需要在插入过程中引入if判断是否需要扩容即可；关于第三个问题，我们可以很容易想到，我们只需要将顺序表的元素从尾部开始依次向后移动一位直到空出需要插入的位置，再将需要插入的元素插入需要插入的位置即可。综上，我们可以很容易写出代码，即：\nint insertlist(arraylist list, int element, int index)&#123;  if(index&lt;1||index&gt;list-&gt;size+1)    return 0;  if(list-&gt;size==list-&gt;capacity)  &#123;    if(!extendlist(arraylist list))      return 0;  &#125;  int i;  for(i=list-&gt;size; i&gt;index-1; i--)    list-&gt;array[i]=list-&gt;array[i-1];  list-&gt;array[index-1]=element;  list-&gt;size++;  return 1;&#125;\n\n删除当我们学会了插入后，再学习删除是非常简单的，我们只需要根据位置信息，就可以将顺序表中的某个元素删除，值得注意是，输入的位置信息也需要在合法的范围内，代码即：\nint deletelist(arraylist list, int index)&#123;  if(index&lt;1||index&gt;list-&gt;size)    return 0;  int i;  for(i=index-1; i&lt;list-&gt;size; i++)    list-&gt;array[i]=list-&gt;array[i+1];  list-&gt;size--;  return 1;&#125;\n\n查找长度查找长度相当简单，我们只需要向主程序返回size值即可，即：\nint sizelist(array list)&#123;  return list-&gt;size;&#125;\n\n查找元素查找元素也同样简单，我们可以选择多种查找方式，这里我们采用简单的遍历查找，即：\nint findlist(arraylist list, int element)&#123;  int i;  for(i=0; i&lt;list-&gt;size; i++)    if(list-&gt;array[i]==element)      return i+1;//数组从0开始，顺序表从1开始，故i+1  return 0;&#125;\n\n查找索引查找索引即查找某个位置上对应元素的值，有了上述模块的经验，我们很容易设计出一个功能齐全的函数，即：\nint* getlist(arraylist list, int index)&#123;  if(index&lt;1||index&gt;list-&gt;size)    return NULL;  return &amp;list-&gt;array[index-1];//注意数组索引和顺序表索引的区别&#125;\n\n打印打印顺序表索引元素的函数也同样简单，即：\nvoid printlist(arraylist list)&#123;  int i;  for(i=0; i&lt;list-&gt;size; i++)    printf(&quot;%d &quot;,list-&gt;array[i]);  printf(&quot;\\n&quot;);&#125;\n\n销毁当我们使用完顺序表后，有时候需要销毁它释放内存，此时我们可以用free()函数来进行操作，free()函数必须与malloc()函数配套使用，即：\nint destorylist(arraylist list)&#123;  if(list-&gt;array==NULL)    return 0;  free(list-&gt;array);  list-&gt;array=NULL;  list-capacity=0;  list-&gt;size=0;  return 1;&#125;\n\n总结顺序表作为数据结构的第一节，并不算难，我们关键是要从中领会思想，学习一些函数的用法，为接下来链表的学习打好基础。\n附代码全代码如下：\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct list&#123;  int* array;  int capacity;  int size;&#125;;typedef struct list* arraylist;int setuplist(arraylist list)&#123;  list-&gt;capacity=1;  list-&gt;array=malloc(sizeof(int)*list-&gt;capacity);  if(list-&gt;array==NULL)    return 0;  list-&gt;size=0;  return 1;&#125;int extendlist(arraylist list)&#123;  int newcapacity=list-&gt;capacity*2;//内存扩展两倍  int* newarray=realloc(list-&gt;array, sizeof(int)*newcapacity);  if(newarray==NULL)    return 0;  list-&gt;array=newarray;  list-&gt;capacity=newcapacity;  return 1;&#125;int insertlist(arraylist list, int element, int index)&#123;  if(index&lt;1||index&gt;list-&gt;size+1)    return 0;  if(list-&gt;size==list-&gt;capacity)  &#123;    if(!extendlist(arraylist list))      return 0;  &#125;  int i;  for(i=list-&gt;size;i&gt;index-1;--i)    list-&gt;array[i]=list-&gt;array[i-1];  list-&gt;array[index-1]=element;  list-&gt;size++;  return 1;&#125;int deletelist(arraylist list, int index)&#123;  if(index&lt;1||index&gt;list-&gt;size)    return 0;  int i;  for(i=index-1; i&lt;list-&gt;size; i++)    list-&gt;array[i]=list-&gt;array[i+1];  list-&gt;size--;  return 0;&#125;int sizelist(arraylist list)&#123;  return list-&gt;size;&#125;int findlist(arraylist list, int element)&#123;  int i;  for(i=0; i&lt;list-&gt;size; i++)    if(list-&gt;array[i]==element)      return i+1;  return 0;&#125;int* getlist(arraylist list, int index)&#123;  if(index&lt;1||index&gt;list-&gt;size)    return NULL;  return &amp;list-&gt;array[index-1];&#125;void printlist(arraylist list)&#123;  int i;  for(i=0; i&lt;list-&gt;size; i++)    printf(&quot;%d &quot;,list-&gt;array[i]);  printf(&quot;\\n&quot;);&#125;int destorylist(arraylist list)&#123;  if(list-&gt;array==NULL)    return 0;  free(list-&gt;array);  list-&gt;array=NULL;  list-capacity=0;  list-&gt;size=0;  return 1;&#125;int main()&#123;...&#125;\n\n返回目录你可以点击此处返回或查看目录。\n","categories":["数据结构"],"tags":["C语言","教程","数据结构"]},{"title":"数据结构_04：特殊链表","url":"/2023/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-04%EF%BC%9A%E7%89%B9%E6%AE%8A%E9%93%BE%E8%A1%A8/","content":"双向链表在单链表，也就是上一节提到的普通链表中，当我们需要完成插入或者删除操作时，我们通常需要找到需要操作的链结的上一个链结，为了解决这个问题，双向链表应运而生。双向链表的结构如下图所示：基于双向链表的不同结构，我们需要对定义结构体，初始化，插入和删除功能进行更新，而其他功能的实现则与单链表相同。\n定义结构体对于双向链表需要指向前一个链结的功能，我们需要在结构体中添加一个结构体指针变量来指向前一个结点，即：\nstruct listnode&#123;  int element;  struct listnode* next;  struct listnode* prev;&#125;\n\n由于已经有了单链表基础，对于定义结构体此处不再过多赘述。\n初始化双向链表在初始化时只需要将前链也设置为NULL即可，其余的和本教程中单链表一样，在初始化时仅对头链结进行进行初始化，同时对结构体指针重命名以便于后续操作，即：\ntypedef struct listnode* Node;void setuphead(Node headnode)&#123;  headnode=malloc(sizeof(struct listnode));  headnode-&gt;next=NULL;  headnode-&gt;prev=NULL;&#125;\n\n插入和单链表不同的是，双向链表在插入时需要操作的链更多，这里我们依然用一个流程图来解释全过程：基于此流程图，我们可以设计出一下代码，即：\nint insertlist(Node head, int element, int index)&#123;  if(index&lt;1)    return 0;  while(--index)  &#123;    head=head-&gt;next;//向后寻找到插入结点的前结点    if(head==NULL)//插入位置非法      return 0;  &#125;  Node node=malloc(sizeof(struct listnode));//新建一个链结并为其申请内存  if(node==NULL)//判断申请内存是否失败，失败返回0    return 0;  node-&gt;element=element;  if(head-&gt;next)//先处理后结点，若存在  &#123;    node-&gt;next=head-&gt;next;    head-&gt;next-&gt;prev=node;  &#125;  else//若后结点不存在  &#123;    node-&gt;next=NULL;  &#125;  head-&gt;next=node;//操作前结点  node-&gt;prev=head;  return 1;&#125;\n\n再完成这一系列操作后，我们可以将其正向反向分别遍历一遍以测试效果。\n删除删除操作相较于插入较为简单，先看流程图：据此，我们很容易设计出代码，即：\nint deletelist(Node head, int index)&#123;  if(index &lt; 1)//先找到位置    return 0;  while(--index)  &#123;    head=head-&gt;next;    if(head == NULL)      return 0;  &#125;  if(head-&gt;next==NULL)    return 0;  Node tmp=head-&gt;next;  if(head-&gt;next-&gt;next)//删除非尾结点  &#123;    head-&gt;next-&gt;next-&gt;prev=head;    head-&gt;next=head-&gt;next-&gt;next;  &#125;  else  &#123;    head-&gt;next=NULL;//删除尾结点  &#125;  free(tmp);  tmp=NULL;  return 1;&#125;\n双向链表的其他操作与单链表大致相同，这里就不做介绍了。\n循环链表相对于普通链表，循环链表多了一个尾结点指向头结点的链，这样的链表从任意结点出发都可以达到任意结点，结构如下图所示：循环链表的代码较为简单，仅仅需要在普通链表的基础上将尾结点指向头结点即可，这里不做赘述。\n总结双向链表和循环链表本质上还是链表，它们只是链表为了适应不同环境的产物，这也就启发我们在实际运用数据结构时也要根据实际情况进行变化。\n返回目录你可以点击此处返回或查看目录。\n","categories":["数据结构"],"tags":["C语言","教程","数据结构"]},{"title":"数据结构_03：链表","url":"/2023/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-03%EF%BC%9A%E9%93%BE%E8%A1%A8/","content":"链表链，是一种什么样的东西呢？现实生活中我们都见过铁链金链和银链，它们都有一个特点，是一个环节一个环节环环相扣连接在一起的。而链表，则是一种具有相似结构的数据结构。在链表中，每一个环节，即链结，都需要负责实现两个功能：\n\n记录某些数值；\n指向下一链结。\n\n一般而言，链表可以分为两种，一种头链结为空仅指向第二个链结，另一种头链结不为空。这里我们只介绍前面一种。\n定义结构体在此之前我们已经达成了对于链结功能的共识，为了方便我们将每一个小的链结都定义成一个结构体，即：\nstruct listnode&#123;  int element;  struct listnode* next;&#125;;\n\n在这个结构体中，我们定义了两个成员整型变量element和结构体指针变量next。其中，element负责执行第一个功能，记录某些数值，而next负责指向下一个链结。\n初始化网上很多教程在初始化时会提前预想可能的链结个数，本教程奉行即插即建即用原则，在初始化时仅对头链结进行进行初始化。和顺序表一样，我们可以用typedef函数将结构体指针重命名以便于后续操作，即：\ntypedef struct listnode* Node;void setuphead(Node headnode)&#123;  headnode=malloc(sizeof(struct listnode));  headnode-&gt;next=NULL;&#125;\n\n在这个代码中，我们用malloc()函数为头链结申请了一块空间，接着保证不指向其他链结。\n判空有时我们需要判断一个链表是否为空，根据链表的性质，我们只需要判断头链结是否指向其他链结即可，即：\nint emptylist(Node headnode)&#123;  if(headnode-&gt;next)    return 1;  return 0;//0为空，1为非空&#125;\n\n插入和链子一样，链表的插入只需要将插入项与理论上的下一链结连接，再将原来连接这一链结的前一链结链接插入项即可。这个过程描述起来有些抽象，其实很多人对链表这个概念到现在都很模糊，无妨，且看下面的流程图：在上述流程图中，我们我们表明了链结的序号，其中，序号0即为头链结。至此我们已经知道了链表插入的操作流程，接下来我们就可以写程序来实现这个功能了，即：\nint insertlist(Node head, int element, int index)&#123;  if(index&lt;1)    return 0;  while(--index)  &#123;    head=head-&gt;next;//向后寻找到插入结点的前结点    if(head==NULL)//插入位置非法      return 0;  &#125;  Node node=malloc(sizeof(struct listnode));//新建一个链结并为其申请内存  if(node==NULL)//判断申请内存是否失败，失败返回0    return 0;  node-&gt;element=element;  node-&gt;next=head-&gt;next;  head-&gt;next=node;  return 1;&#125;\n\n删除与插入相似的，从链表中删除一个元素只需要断开该元素与指向这个元素的链结之间的联系，并且将指向该元素的链结指向该元素指向的链结。乍一听可能有些抽象，这里我们同样用一个流程图来表述：通过该流程图，我们可以很好地理解删除的全过程，即：\nint deletelist(Node head, int index)&#123;  if(index&lt;1)    return 0;  while(--index)  &#123;    head=head-&gt;next;    if(head==NULL)      return 0;  &#125;  if(head-&gt;next==NULL)    return 0;  Node tmp=head-&gt;next;  head-&gt;next=head-&gt;next-&gt;next;  free(tmp);  tmp=NULL;  return 1;&#125;\n\n查找长度和顺序表不一样的是，我们在构建链表结构体时并没有引入一个变量来表示链表的长度，但是根据链表的定义，我们可以很容易地知道，一个链表的最后一个链结并不指向其他链结，所以我们只需要从头开始遍历整个链表，找到那个特殊的链结即可，即：\nint sizelist(Node head)&#123;  int i=1;  while(head)  &#123;    head=head-&gt;next;    i++;  &#125;  return i;&#125;\n\n查找元素在查找元素这个操作中，我们可以很容易采取遍历查找的方式来实现，即：\nint findlist(Node head, int element)&#123;  head=head-&gt;next;  int i=1;  while(head)  &#123;    if(head-&gt;element==element)      return i;    head=head-&gt;next;    i++;  &#125;  return 0;&#125;\n\n查找索引和顺序表不一样的是，我们在定义链表结构体时并没有引入索引这一变量，这也就导致了我们在查找索引时必须要从表头开始查找，因而在执行查找索引这一操作上链表的效率低于顺序表。我们可以很容易地用遍历的方法来实现查找索引的功能，即：\nint* getlist(Node head, int index)&#123;  if(index&lt;1)    return 0;  do  &#123;    head=head-&gt;next;    if(head==NULL)      return 0;  &#125;  while(--index);  return &amp;head-&gt;element;&#125;\n\n打印当我们想要实现打印链表功能时，我们只需要从头开始边遍历整个链表边打印元素直至链结不再指向下一链结为止，即：\nvoid printlist(Node head)&#123;  while(head-&gt;next)  &#123;    head=head-&gt;next;    printf(&quot;%d &quot;,head-&gt;element);  &#125;  printf(&quot;\\n&quot;);&#125;\n\n顺序表与链表的区别如果我们深入思考了上一节中讲的顺序表，我们会发现它在一定程度上和数组十分相似，并且它在存储时也是一段连续的内存，而本节所讲的链表是不连续存储的。在我们日常生活中，有时会遇到顺序表和链表如何抉择的问题。一个数据结构往往要实现增删查改四个功能。其实，当我们仔细比较其优缺点后，我们很容易发现顺序表在查改方面存在优势，而链表在增删方面存在优势。这也就意味着，当我们实际使用时，可以根据所用的次数来决定如何选择。\n总结链表作为一个经典的数据结构，在学习上会存在着一定的难度。但是，有了前面顺序表的基础，再加上认真钻研，实际理解起来还是很简单的。值得注意的是，数据结构并不是一门基于某某语言的课程，实际上，我们可以用任何语言来写数据结构。同时，即便是同种语言下的数据结构，在实现起来也会存在代码的不同，本教程仅仅提供一种解决方案。我们在学习时，一定不要局限于形式上的不同，关键要领略其核心思想，勤于思考才能事半功倍。\n附代码#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct listnode&#123;  int element;  struct listnode* next;&#125;;typedef struct listnode* Node;void setuphead(Node headnode)&#123;  headnode=malloc(sizeof(struct listnode));  headnode-&gt;next=NULL;&#125;int emptylist(Node headnode)&#123;  if(headnode-&gt;next)    return 1;  return 0;//0为空，1为非空&#125;int insertlist(Node head, int element, int index)&#123;  if(index&lt;1)    return 0;  while(--index)  &#123;    head=head-&gt;next;    if(head==NULL)      return 0;  &#125;  Node node=malloc(sizeof(struct listnode));  if(node==NULL)    return 0;  node-&gt;element=element;  node-&gt;next=head-&gt;next;  head-&gt;next=node;  return 1;&#125;int deletelist(Node head, int index)&#123;  if(index&lt;1)    return 0;  while(--index)  &#123;    head=head-&gt;next;    if(head==NULL)      return 0;  &#125;  if(head-&gt;next==NULL)    return 0;  Node tmp=head-&gt;next;  head-&gt;next=head-&gt;next-&gt;next;  free(tmp);  tmp=NULL;  return 1;&#125;int sizelist(Node head)&#123;  int i=1;  while(head)  &#123;    head=head-&gt;next;    i++;  &#125;  return i;&#125;int findlist(Node head, int element)&#123;  head=head-&gt;next;  int i=1;  while(head)  &#123;    if(head-&gt;element==element)    return i;    head=head-&gt;next;    i++;  &#125;  return 0;&#125;int* getlist(Node head, int index)&#123;  if(index&lt;1)  return 0;  do  &#123;    head=head-&gt;next;    if(head==NULL)      return 0;  &#125;  while(--index);  return &amp;head-&gt;element;&#125;void printlist(Node head)&#123;  while(head-&gt;next)  &#123;    head=head-&gt;next;    printf(&quot;%d &quot;,head-&gt;element);  &#125;  printf(&quot;\\n&quot;);&#125;int main()&#123;  ...&#125;\n\n参考资料本教程参考资料如下：\n\nB站视频：《数据结构与算法 已完结（CLion 2022 最新版）4K蓝光画质+杜比音效 全程高能》《【强烈推荐】深入浅出数据结构 - 顶尖程序员图文讲解 - UP主翻译校对 (已完结)》\nCSDN文章：《c语言链表详解（超详细）》《关于链表，看这一篇就够了！（新手入门）》《链表(开辟和不开辟新空间)》。\n\n返回目录你可以点击此处返回或查看目录。\n","categories":["数据结构"],"tags":["C语言","教程","数据结构"]},{"title":"数据结构_05：栈","url":"/2023/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-05%EF%BC%9A%E6%A0%88/","content":"栈的概念汉语中对栈字的解释是存储货物或供旅客住宿的房屋，对应的，在计算机中栈指的是数据暂时存储的地方。栈的特点，就像我们玩的俄罗斯方块一样，我们只能在最顶部进行操作。对此，我们总结为先进后出、后进先出。对此，我们可以有流程图便于理解：\n顺序表实现栈栈的实现可以基于顺序表或是链表，这里我们先用顺序表实现，这里我们需要实现两个新的功能：\n\n入栈（push）：入栈操作，向栈中压入一个新的元素；\n出栈（pop）：出栈操作，从栈顶取出一个元素。\n\n定义结构体这里我们基于顺序表设计，即：\nstruct stack&#123;  int* array;  int capacity;  int top;//当前的栈顶&#125;\n\n初始化这里我们基于顺序表设计，即：\ntypedef struct stack* arraystack;int setupstack(arraystack stack_)&#123;  stack_-&gt;array=malloc(sizeof(int)*10);//初始容量为10  if(stack_-&gt;array==NULL)    return 0;    stack_-&gt;capacity=10;    stack_-&gt;top=-1;//由于没有元素，栈顶默认为-1    return 1;&#125;\n\n扩容在正式开始设计入栈功能之前，我们可以预料到在入栈时可能会产生容量不够的情况，故我们可以先设计扩容功能，即：\nint extendstack(arraystack stack_)&#123;  int newcapacity=stack_-&gt;capacity*2;//内存扩展两倍  int* newarray=realloc(stack_-&gt;array, sizeof(int)*newcapacity);  if(newarray==NULL)    return 0;  stack_-&gt;array=newarray;  stack_-&gt;capacity=newcapacity;  return 1;&#125;\n\n入栈由于栈只能从尾部插入，所以入栈操作实现起来非常简单，同时我们需要用上刚刚设计好的扩容，即：\nint pushstack(arraystack satck_, int element)&#123;  if(stack_-&gt;top+1==stack-&gt;capacity)  &#123;    if(!extendstack(stack_))      return 0;  &#125;  stack_-&gt;array[stack-&gt;top+1]=element;  stack_-&gt;top++;  return 1;&#125;\n\n判空在出栈之前，我们需要判断一下栈是否为空，即：\nint isempty(arraystack stack_)&#123;  if(!stack_-&gt;+1)    return 0;  return 1;//为空时返回0，不为空时返回1&#125;\n\n出栈出栈操作便更加简单了，只需要将栈顶元素取出即可，即：\nint popstack(arraystack stack_)&#123;  return stack_-&gt;array[stack_-&gt;top--]&#125;\n\n共享栈为了提高栈的利用率，我们可以将一个固定长度的数组共享给两个栈来使用，将数组的两头作为两个栈的栈底，当两个栈的栈顶想要时表示栈已满。\n链表实现栈在上文中我们介绍了用顺序表实现栈，然而在实际中，使用链表来实现栈会显得更加方便。我们规定链表表头指向栈顶，而栈顶指向后续的元素直至栈底。每当有新的元素入栈，我们只需要在链表头部插入新的结点即可。\n初始化有链表作为基础，我们可以很容易初始化，即：\nstruct listnode&#123;  int element;  struct listnode* next;&#125;typedef struct listnode* Node;void setuplist(Node head)&#123;  head-&gt;next=NULL;&#125;\n\n入栈有链表作为基础，我们可以很容易的入栈，即：\nint pushstack(Node head, int element)&#123;  Node node=malloc(sizeof(struct listnode));  if(node==NULL)    return 0;  node-&gt;next=head-&gt;next;  node-&gt;element=element;  head-&gt;next=node;  return 1;&#125;\n\n判空在出栈之前我们需要判断栈是否为空，和链表类似的，我们只需要看头结点即可，即：\nint isempty(Node head)&#123;  if(head-&gt;next)    return 1;  return 0;&#125;\n\n出栈有上文和链表作为基础，我们可以很容易实现出栈，即：\nint popstack(Node head)&#123;  Node top=head-&gt;next;  head-&gt;next=head-&gt;next-&gt;next;  int tmp=top-&gt;element;  free(top);  top=NUll;  return tmp;//返回栈顶元素&#125;\n\n总结栈本质上是基于前面所说的两种线性表的一种特殊线性表，有前面的学习作为基础，在学习时并不会产生多大困难。相似的，下一节所讲的队列也是一种特殊的线性表。\n返回目录你可以点击此处返回或查看目录。\n","categories":["数据结构"],"tags":["C语言","教程","数据结构"]},{"title":"来自云上的湍流","url":"/2022/09/07/%E6%9D%A5%E8%87%AA%E4%BA%91%E4%B8%8A%E7%9A%84%E6%B9%8D%E6%B5%81/","content":"欢迎来到本blog，很高兴在此与大家相识！\n","categories":["杂项"],"tags":["杂项"]}]